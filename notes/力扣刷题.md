# 力扣刷题

这是我跟着**[carl](https://github.com/youngyangyang04/leetcode-master)**刷算法的流程作下的笔记，主要是记录的题型和思想，这里主要就是想告诉自己从何处开始，说实话一开始我也不知道从哪刷起，在同学的推荐下就开始跟着去做了，谈不上每天都去刷吧，大部分时间都是有刷题的，笔记中也记录了时间，前面的题目是我一开始随便刷的，直接可以跳数组开始！！



日期:2021年3月27日



##### [子数组的和的最大值](https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/)

输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。

要求时间复杂度为O(n)。(核心算法:动态规划方法)

 **示例1:** 

```
输入: nums = [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```

**动态规划**: （基本思想）

把原问题分解为相对简单的子问题的方式求解复杂问题的方法 , 常常适用于有重叠子问题和最优子结构性质的问题 。

 动态规划能解决的问题是无后效性的问题（也称马尔科夫性问题）。所谓无后效性指系统到达某个状态前的过程的决策将不影响到该状态以后的决策。[指系统从某个阶段往后的发展，仅由本阶段所处的状态及其往后的决策所决定，与系统以前经历的状态和决策（历史）无关。过程的过去历史只能通过当前的状态去影响它未来的发展]。 

典型例题:0、1背包问题。

此题目相比0、1背包问题相对简单，只有一个变量，要求只在一个数组中找出子数组和的最大值，思路：创建一个新的数组(dp)，用来存放与原数组（nums）比较之后的值，从原数组头开始遍历，比较筛选出较大的值（**dp[i] = Math.max(dp[i-1]+nums[i],nums[i]);**），最后选出**连续**子数组的最大值。



日期：2021年4月7号



##### [**转置矩阵**](https://leetcode-cn.com/problems/transpose-matrix/)

给你一个二维整数数组 `matrix`， 返回 `matrix` 的 **转置矩阵** 。

矩阵的 **转置** 是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。

给你一个二维整数数组 `matrix`， 返回 `matrix` 的 **转置矩阵** 。

矩阵的 **转置** 是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。

![image-20210407200556603](https://gitee.com/zhanghui2233/image-storage-warehouse/raw/master/img//image-20210407200556603.png)

```
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[[1,4,7],[2,5,8],[3,6,9]]

输入：matrix = [[1,2,3],[4,5,6]]
输出：[[1,4],[2,5],[3,6]]
```

思路：将矩阵的行号和列号做对应的交换 result[i] [j] =  matrix[j] [i]

注意: 矩阵的行长和列长不一定相等，for循环遍历的时候注意长度对应。



##### [主要元素](https://leetcode-cn.com/problems/find-majority-element-lcci/)

 数组中占比超过一半的元素称之为主要元素。给定一个**整数**数组，找到它的主要元素。若没有，返回-1。 

```
输入：[1,2,5,9,5,9,5,5,5]
输出：5

输入：[3,2]
输出：-1
```

解法一：通过快速排序先将数组进行排序，重复的元素（主要元素）会位于数组中，对数组取中间值，for循环遍历找出与中间值相同数的数量，如果中间值数目占比超过数组一半就输出中间值，否则输出-1。



解法二：摩尔投票法(最好的方法)

1. 遍历两次 `nums `数组，时间复杂度为 O(n)*O*(*n*)。

2. 只定义了几个临时变量，时间复杂度为 O(1)*O*(1)。

   什么是**摩尔投票法**？

   主要分为比拼消耗 pairing 阶段和统计 counting 阶段。
   它基于这样一个事实：任意删除数组中两个不同的数，直至数组中不存在相同的数，那么剩下的数就是主要元素。

形象化理解：诸侯争霸游戏，假设你的人口占比超过总人口的一半，那么只要不内斗，每次和其他国家打仗都能一换一，最终赢家肯定是你。即使其他国家联合起来也打不过你，更不用说其他国家之间也会相互攻击。

个人理解:取数组第一个数作为初始数据，同时定一个变量记录数量变化，for遍历数组做判断：如果找到相同的数组，变量加一，如果不相同，变量减一，当变量为0 时取当前遍历的数值，变量加一，继续遍历判断直至遍历完毕。到目前为止，投票的过程结束了，接下来就是统计的过程，先判断变量是否为0，如果为0就输出-1，表明此数组没有主要元素，不为0，将取到的变量再做一次for遍历找相同变量的个数和数组的一半作比较。



日期:2021年4月8日

##### [旋转矩阵](https://leetcode-cn.com/problems/rotate-matrix-lcci/)

 给你一幅由 `N × N` 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度 。

```
给定 matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

原地旋转输入矩阵，使其变为:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
```

方法一：使用辅助矩阵

示例:

![image-20210408200444643](https://gitee.com/zhanghui2233/image-storage-warehouse/raw/master/img//image-20210408200444643.png)

思想:通过旋转90°找出相应的规律，矩阵中第i行第j个元素旋转过后得到位于矩阵中倒数第i列第j的位置。

**matrix[i] [j] = result[j] [length -1-i]**

最后将旋转过后的数组result再赋值给matrix。

时间复杂度：O(N^2)。

空间复杂度：O(N^2)。



方法二：通过先水平翻转，再通过矩阵主对角线翻转得到

![image-20210408203616456](https://gitee.com/zhanghui2233/image-storage-warehouse/raw/master/img//image-20210408203616456.png)

还是应用上面的例子

```
for(i= 0; i< length/2 ; i++){
	for(j= 0; j< length ; i++){
		int tmp = matrix[i][j];
		matrix[i][j] = matrix[length - i -1][j];
        matrix[length - i -1][j] = temp; 
	}
}    （水平翻转）核心
```



日期:2021年4月10日

##### [丑数](https://leetcode-cn.com/problems/ugly-number/)

给你一个整数 n ，请你判断 n 是否为 丑数 。如果是，返回 true ；否则，返回 false 。

丑数 就是只包含质因数 2、3 和/或 5 的正整数。

```
输入：n = 6
输出：true
解释：6 = 2 × 3

输入：n = 8
输出：true
解释：8 = 2 × 2 × 2

输入：n = 14
输出：false
解释：14 不是丑数，因为它包含了另外一个质因数 7 。
```

```
/** * 丑数概念:可以也只能被2、3、5这三个质因子整除， * 质因子：能够整除给定的正整数的质数 * 质数：只能被1和自身整除的数 * 丑数判断 */
```

思想:整除2、3、5的顺序不重要，给定一个正整数先和2整除，判断是否能整除，如果不能整除就和剩下的3、5做整除，如果都不能整除那这个正整数就不是一个丑数。如果可以整除就一直整除下去，直到不能再进行整除，最后看余数是否为1，如果是1那就是丑数。



编写一个程序，找出第 `n` 个丑数。

丑数就是质因数只包含 `2, 3, 5` 的**正整数**。



##### [丑数Ⅱ](https://leetcode-cn.com/problems/ugly-number-ii/)

编写一个程序，找出第 `n` 个丑数。

丑数就是质因数只包含 `2, 3, 5` 的**正整数**。

```
输入: n = 10
输出: 12
解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。
1 是丑数。
n 不超过1690。
```

思想一(**废弃，效率太低了**) 暴力法

通过一个一个数去做判断，如果数量太大，不仅效率太低了。



思想二:最小堆

用到Set集合、优先权队列(PriorityQueue)

1是最小的丑数，通过1和2、3、5的乘积得到的数一定是丑数，那么就可以通过得到的第二个丑数2和2、3、5分别相乘得到新的丑数，但是当中有重复的数，因此用到了Set集合，通过优先权对队列拿到队列最小的丑数，来得到新的丑数。



日期：2021年4月11日

##### 简单:[ 左旋转字符串](https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)

字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"。



```
输入: s = "abcdefg", k = 2
输出: "cdefgab"

输入: s = "lrloseumgh", k = 6
输出: "umghlrlose"
```



方法一:String类中提供的subString方法进行字符串的分割和拼接

方法二:遍历拼接，利用StringBuilder类中的append方法和String类中的CharAt方法。



##### [二进制求和](https://leetcode-cn.com/problems/add-binary/)

给你两个二进制字符串，返回它们的和（用二进制表示）。

输入为 **非空** 字符串且只包含数字 `1` 和 `0`。



```
输入: a = "11", b = "1"
输出: "100"

输入: a = "1010", b = "1011"
输出: "10101"
```

思想:首先比较两个二进制字符串的长度，取较长的作为遍历,采用二进制求和方式，低位对齐，逢二进一，每次计算都要考虑到低位向高位进位，因此定义一个carry变量初始为0，从一开始就做加法计算，通过charAt方法取字符（ **通过charAt(i)，把字符串的每位变成char型，然后用当前字符减去字符0**  ），取得字符和'0'做减法， 得到当前字符的int值 。相加之后得到的结果取余数，将余数加入到StringBuilder中，将carry变量除2取商，carry要继续参与下一轮的计算，循环完之后，最后要判断一下，carry是否为0 ，不为0 说明有低位向高位进位，最后将StringBuilder翻转，因为添加的过程和结果是相反的。



日期：2021年4月12日

##### [二级制手表](https://leetcode-cn.com/problems/binary-watch/)

二进制手表顶部有 4 个 LED 代表 小时（0-11），底部的 6 个 LED 代表 分钟（0-59）。每个 LED 代表一个 0 或 1，最低位在右侧。

条件：

- 输出的顺序没有要求。
- 小时不会以零开头，比如 “01:00” 是不允许的，应为 “1:00”。

- 分钟必须由两位数组成，可能会以零开头，比如 “10:2” 是无效的，应为 “10:02”。
- 超过表示范围（小时 0-11，分钟 0-59）的数据将会被舍弃，也就是说不会出现 "13:00", "0:61" 等时间。

```
输入: n = 1
返回: ["1:00", "2:00", "4:00", "8:00", "0:01", "0:02", "0:04", "0:08", "0:16", "0:32"]

```

思想**:灯亮对应二进制数1**

根据1的个数(灯亮数)来输出对应的所有时间，时钟范围是0-11，分钟范围是0-59，通过遍历时钟(**int**)和分钟(**int**)来寻找和输入值相等的1的个数，然后输出。**Integer类中->Integer.bitCount() 可用于统计 int 值所对应的二进制中 1 的个数**。

(也可以通过循环取余法)--->来获取1的个数

```
num %2 == 1  **等价于**   num & 1 == 1
```



日期：2021年4月15日

[二分搜索](https://leetcode-cn.com/problems/binary-search/)

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

```
输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4

输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1
```

思想：二分搜索也叫对半搜索，也就是每次搜索的范围都是上次搜索的一般，当然要根据target来选取合适的范围，当目标不在搜索范围要跳出搜索。





[寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)

已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：
若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]
若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]
注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。

给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。



```
输入：nums = [11,13,15,17]
输出：11
解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。

输入：nums = [4,5,6,7,0,1,2]
输出：0
解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。

输入：nums = [3,4,5,1,2]
输出：1
解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。
```

思想：当数组没有做旋转的时候，所给数组是一个单调递增的，那么最小值就是第一个，如果数组做了n次旋转，此时的数组不再是递增的，它呈现的是一个区域性的变化，当找到的一个区域是单调递增的那么最小值肯定不在这里，如果找到区域值是呈波动那么最小值肯定在这里，这时候通过二分搜索，不断缩小区域，找到最小值。



##### [寻找旋转排序数组中的最小值 II](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/)

已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,4,4,5,6,7] 在变化后可能得到：
若旋转 4 次，则可以得到 [4,5,6,7,0,1,4]
若旋转 7 次，则可以得到 [0,1,4,4,5,6,7]
注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。

给你一个可能存在 重复 元素值的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。



```
输入：nums = [1,3,5]
输出：1
输入：nums = [2,2,2,0,1]
输出：0
```



**需要加强回顾，顾先不做思路的记录**



日期：2021年4月18日

##### [上升下降字符串](https://leetcode-cn.com/problems/increasing-decreasing-string/)

给你一个字符串 s ，请你根据下面的算法重新构造字符串：

从 s 中选出 最小 的字符，将它 接在 结果字符串的后面。
从 s 剩余字符中选出 最小 的字符，且该字符比上一个添加的字符大，将它 接在 结果字符串后面。
重复步骤 2 ，直到你没法从 s 中选择字符。
从 s 中选出 最大 的字符，将它 接在 结果字符串的后面。
从 s 剩余字符中选出 最大 的字符，且该字符比上一个添加的字符小，将它 接在 结果字符串后面。
重复步骤 5 ，直到你没法从 s 中选择字符。
重复步骤 1 到 6 ，直到 s 中所有字符都已经被选过。
在任何一步中，如果最小或者最大字符不止一个 ，你可以选择其中任意一个，并将其添加到结果字符串。

请你返回将 s 中字符重新排序后的 结果字符串 。

```
输入：s = "aaaabbbbcccc"
输出："abccbaabccba"
解释：第一轮的步骤 1，2，3 后，结果字符串为 result = "abc"
第一轮的步骤 4，5，6 后，结果字符串为 result = "abccba"
第一轮结束，现在 s = "aabbcc" ，我们再次回到步骤 1
第二轮的步骤 1，2，3 后，结果字符串为 result = "abccbaabc"
第二轮的步骤 4，5，6 后，结果字符串为 result = "abccbaabccba"

输入：s = "rat"
输出："art"
解释：单词 "rat" 在上述算法重排序以后变成 "art"


输入：s = "leetcode"
输出："cdelotee"


输入：s = "ggggggg"
输出："ggggggg"

输入：s = "spo"
输出："ops"

```



```java
 /**
     * 桶排法
     * @param s 给定字符串
     * @return 排序好的字符串
     */
    public static String upDownString(String s){
        StringBuilder stringBuilder = new StringBuilder();
        char[] chars = s.toCharArray();
        int index = 0;
        int[] barrel = new int[26];
        //将字符放入对应的位置  0-25  -----> a-z
        for (char c : chars) {
            //长度为26的数组代表26个小写字母，数组索引中对应的值表示当前字母的个数
            barrel[c - 'a']++;
        }
        //阅读题目发现，将给定的数组进行一边升序排序再进行一次降序排序，直到所有字符都排完为止结束

       while (index < chars.length){
           //升序排列
           for (int i = 0; i < 26 ; i++) {
               if (barrel[i] != 0){
                   stringBuilder.append(((char)(i + 'a')));
                   barrel[i]--;
                   index++;
               }
           }
           for (int i = 25; i >= 0  ; i--) {
               if (barrel[i] != 0){
                   stringBuilder.append((char)(i + 'a'));
                   barrel[i]--;
                   index++;
               }
           }
       }


        return String.valueOf(stringBuilder);


        /**
         * 另一个版本，区别在于原来用的是Stringbuilder来进行result的拼接，改用char[]数组来拼接，消耗的内存会更小，速度也会更快。
         */
//        // StringBuilder stringBuilder = new StringBuilder();
//        char[] chars = s.toCharArray();
//        char[] result = new char[chars.length];
//        int index = 0;
//        int[] barrel = new int[26];
//        //将字符放入对应的位置  0-25  -----> a-z
//        for (char c : chars) {
//            //长度为26的数组代表26个小写字母，数组索引中对应的值表示当前字母的个数
//            barrel[c - 'a']++;
//        }
//        //阅读题目发现，将给定的数组进行一边升序排序再进行一次降序排序，直到所有字符都排完为止结束
//
//        while (index < chars.length){
//            //升序排列
//            for (int i = 0; i < 26 ; i++) {
//                if (barrel[i] != 0){
//                    result[index++] =(char)(i + 'a');
//                    //    stringBuilder.append(((char)(i + 'a')));
//                    barrel[i]--;
//                }
//            }
//            for (int i = 25; i >= 0  ; i--) {
//                if (barrel[i] != 0){
//                    result[index++] =(char)(i + 'a');
//                    //    stringBuilder.append((char)(i + 'a'));
//                    barrel[i]--;
//                    //    index++;
//                }
//            }
//        }
//
//
//        return new String(result);
    }
```





### 数组

特点:

- 存放在连续内存空间中
- 存放的数据类型相同的集合

![image-20210420204106434](https://gitee.com/zhanghui2233/image-storage-warehouse/raw/master/img//image-20210420204106434.png)



**二维数组特点**

二维数组也叫**矩阵**

二维数组的内存空间地址不是连续的

 二位数组中其实是一个线性数组存放着 其他数组的首地址 

![image-20210420204338994](https://gitee.com/zhanghui2233/image-storage-warehouse/raw/master/img//image-20210420204338994.png)



将一维数组中元素进行移动，一般暴力法：通过两个for循环来将数组中的元素进行移动，很笨拙。

聪明方法就是使用双指针通过一个for循环来进行数组中元素的移动。





日期：2021年4月19日

##### [搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

你可以假设数组中无重复元素。

```
输入: [1,3,5,6], 5
输出: 2

输入: [1,3,5,6], 2
输出: 1

输入: [1,3,5,6], 7
输出: 4

输入: [1,3,5,6], 0
输出: 0
```

```java
/**
     * 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。
     * 如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
     * 思想一:暴力法
     * 根据题目要求可以想到:给定target位于数组中的位置有四种
     * 1.target位于数组最左边,
     * 2.target位于数组最右边
     * 3.target位于数组中间
     * 中间又分为两种:1，target是数组中一个元素，2.target位于数组中元素之间
     * @param nums
     * @param target
     * @return
     */
    public static int searchInsert(int[] nums, int target) {
        for (int i = 0; i <nums.length ; i++) {
            if (nums[i] >= target){
                return i;
            }
        }

        //当遍历完数组，没有找到target对应的索引，那么target大于数组中所有的元素，其位于数组最右边
        return nums.length;

//        时间复杂度：O(n)
//        空间复杂度：O(1)

    }

    /**
     * 思想二:二分搜索方法
     * @param nums
     * @param target
     * @return
     */
    public static int searchInsert1(int[] nums, int target) {
        int star = 0 ;
        int end = nums.length -1 ;
        while (star <= end) {
            int mid = (star + end)  /2 ;
            if (target > nums[mid]){
                star = mid + 1;
            }else if (target < nums[mid]){
                end = mid - 1;
            }else {
                return mid;
            }
        }

        return end + 1;

    }
```







**双指针概念**：

 双指针是一种思想，一种技巧或一种方法，并不是什么特别具体的算法，在**二分查找**等算法中经常用到这个技巧。具体就是用两个变量动态存储两个或多个结点，来方便我们进行一些操作。通常用在**线性的数据结构**中，比如**链表和数组**，有时候也会用在图算法中。 



**快慢指针**

 类似于龟兔赛跑，两个链表上的指针从同一节点出发，其中一个指针前进速度是另一个指针的两倍 。



日期：2021年4月20日

###### [移出元素](https://leetcode-cn.com/problems/remove-element/)

给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

```
输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2]
解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。

输入：nums = [0,1,2,2,3,0,4,2], val = 2
输出：5, nums = [0,1,4,0,3]
解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。

```

暴力法:通过遍历两次数组，找到与target相同的元素，将元素从数组中去除

```
nums[i] = nums[i+1];
nums.length--;
i--;
```

双指针法：通过定义两个指针，left、right，(right要快于left)通过一次遍历，当发现right指针指向的值和target相同时，left指针不动，right指针加一，（**数组中与target相同的值要去掉**）。



日期：2021年4月21日

###### [三树之和](https://leetcode-cn.com/problems/3sum/)

给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。

```
输入：nums = [-4,-1,-1,0,1,2]
输出：[[-1,-1,2],[-1,0,1]]

输入：nums = []
输出：[]

输入：nums = [0]
输出：[]

遇到排序好的数组，想想是否可以用指针或者二分搜索来解决
```

双指针法：通过一个for循环，for循环本身可以看作是一个指针，定义一个left指针、right指针。

```
left = i + 1;
right = nums.length -1;
```

```
//结果大于 0
nums[i] + nums[left] + nums[right] > 0;
//将right指针往左移动
right--;

//结小于 0
nums[i] + nums[left] + nums[right] < 0;
//将left指针往右移动
right++;

//取结果
nums[i] + nums[left] + nums[right] == 0
```



1.如果升序数组第一个元素就大于0，那么这个数组中一定没有三数之和为 0 的结果。

2.升序排列的数组，当中如果出现相同元素可能会导致结果重复，那么for循遍历中遇到循环数组直接跳过//如果使用 i == i+1 来判断 for循环会跳过i，去执行i+1,会导致结果不完整。

3.如果指针指向数组元素符合结果，但是数组元素又出现重复，就需要做判断，跳过重复元素，避免结果重复。判断条件：

```java
//例如数组：{-2,0,0,2,2} 
while (left < right && nums[right] == nums[right - 1])
 {right -- ;}
 while (left < right && nums[left] == nums[left + 1])
 {left++; }
```





###### [四数之和](https://leetcode-cn.com/problems/4sum/submissions/)


给定一个包含 *n* 个整数的数组 `nums` 和一个目标值 `target`，判断 `nums` 中是否存在四个元素 *a，**b，c* 和 *d* ，使得 *a* + *b* + *c* + *d* 的值与 `target` 相等？找出所有满足条件且不重复的四元组。

**注意：**答案中不可以包含重复的四元组。



```
输入：nums = [1,0,-1,0,-2,2], target = 0
输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]


输入：nums = [], target = 0
输出：[]
```

思想：和三数之和类似，就是多了一层for循环，第一层for循环作为第一个指针，第二层for循环作为另外一个指针，在第二个for循环中定义左指针和右指针。







日期:2021年4月22日

###### [长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)

给定一个含有 n 个正整数的数组和一个正整数 target 。

找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。



```
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。

输入：target = 4, nums = [1,4,4]
输出：1

输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0
```

题目要求:子数组和 >=target、长度最小、连续子数组

1.暴力法

通过双重for循环遍历，找到符合条件的子数组，比对每个子数组的长度，找出最小的，没有就返回0。



2.滑动窗口法(双指针)

滑动窗口本身就是一个连续的，因此很适合这样的题目。关键在于如何定义出窗口，并且该如何移动这个窗口。

通过首尾指针定义窗口的范围，通过指针的移动来让窗口移动起来。

窗口移动：起始位置首指针不动，尾指针向后移动，当窗口的值 >=target，首指针开始向前移动，去寻找别的符合条件的子数组，尾指针继续向后移动，循环，直到找出长度最小的子数组，没有就返回0。





日期：2021年4月24日

###### [螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix/)

给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。

  ![img](https://gitee.com/zhanghui2233/image-storage-warehouse/raw/master/img//spiral1.jpg)  ![img](https://gitee.com/zhanghui2233/image-storage-warehouse/raw/master/img//spiral.jpg) 

```
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]

输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]
```



通过上图可以明显看到规律，输出的数组元素，是按照给定矩阵顺时针获取到的。

按照方向来看（死方向）

1.从左往右

2.从上往下

3.从右往左

4.从下往上

遵循这四个方向，加上约束的条件，

条件：1.不能够越界，超出最大行长和列长。2.拿过的元素不能够再拿(创建一个辅助矩阵来做判断，拿过的就赋值)

```java
    /**
     * 按边模拟
     *matrix.length表示的是行数，matrix[0].length表示的是列数
     * @param matrix 给定矩阵
     * @return list
     */
    public static List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> list = new ArrayList<>();

        int rowLength = matrix.length;
        int colLength = matrix[0].length;

        int total = rowLength * colLength;

        int[][] supportMatrix = new int[rowLength][colLength];

        int row = 0;
        int col = 0 ;

        //定义四个方向(按照顺时针)
        // 1.从左往右移动 ----> 矩阵+{0,1}
        // 2.从上往下 ----> 矩阵+{1,0}
        // 3.从右往左 ----> 矩阵+{0,-1}
        // 2.从下往上 ----> 矩阵+{-1,0}
        int[][] direction = {{0,1},{1,0},{0,-1},{-1,0}};
        int dir = 0;


        for (int i = 0; i < total; i++) {
            list.add(matrix[row][col]);
            supportMatrix[row][col] = Integer.MAX_VALUE;

            int nextRow = row + direction[dir][0];
            int nextCol = col + direction[dir][1];
            //越界或者已经走过的数组，对dir的值就要发生改变，dir值的变化，对应row和col的值就要发生变化，这时候方向就发生了变化。
            // 正常情况下，dir值不变就表示没有发生越界或者数组已经走过的情况
            if ( nextCol >= colLength || nextRow >= rowLength  || nextCol < 0 || nextRow < 0 || supportMatrix[nextRow][nextCol] == Integer.MAX_VALUE){
                //四种方向
                dir = (dir + 1) % 4;
            }

            row += direction[dir][0];
            col += direction[dir][1];
        }

        System.out.println(Arrays.toString(list.toArray()));
        return list;

    }
```



###### [螺旋矩阵Ⅱ](https://leetcode-cn.com/problems/spiral-matrix-ii/)

 给你一个正整数 `n` ，生成一个包含 `1` 到 `n2` 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix` 。 

 ![img](https://gitee.com/zhanghui2233/image-storage-warehouse/raw/master/img//spiraln.jpg) 

```
输入：n = 3
输出：[[1,2,3],[8,9,4],[7,6,5]]
```

和螺旋矩阵大同小异。



### 链表

概念：

 链表是一种通过指针串联在一起的线性结构，每一个节点是由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。 



链表类型

**单链表**

 链接的入口点称为列表的头结点也就是head。 

![image-20210424164628039](https://gitee.com/zhanghui2233/image-storage-warehouse/raw/master/img//image-20210424164628039.png)

**双链表**

 单链表中的节点只能指向节点的下一个节点。 

 双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。 

 双链表 既可以**向前查询**也可以**向后查询。** 

![image-20210424164805111](https://gitee.com/zhanghui2233/image-storage-warehouse/raw/master/img//image-20210424164805111.png)



**循环链表**

 循环链表，顾名思义，就是链表首尾相连。 

 循环链表可以用来解决约瑟夫环问题。 

![image-20210424164849851](https://gitee.com/zhanghui2233/image-storage-warehouse/raw/master/img//image-20210424164849851.png)



**链表存储方式**

 数组是在内存中是连续分布的，但是链表在内存中可不是连续分布的。 

链表是通过指针域的指针指向内存中的各个节点。

 所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。 



**链表定义**

 **链表节点的定义** 

 java ListNode 链表 就是用Java自定义实现的链表结构。 

基本结构：

```java
class ListNode {        //类名 ：Java类就是一种自定义的数据结构
    int val;            //数据 ：节点数据 
    ListNode next;      //对象 ：引用下一个节点对象。在Java中没有指针的概念，Java中的引用和C语言的指针类似
}
```



添加构造方法方便初始化：

```java
class ListNode {        //类名 ：Java类就是一种自定义的数据结构
    int val;            //数据 ：节点数据 
    ListNode next;      //对象 ：引用下一个节点对象。在Java中没有指针的概念，Java中的引用和C语言的指针类似
    
    ListNode(int val){  //构造方法 ：构造方法和类名相同   
        this.val=val;     //把接收的参数赋值给当前类的val变量
    }
}
```



 范型写法：使用范型可以兼容不同的数据类型 

```java
class ListNode<E>{                //类名 ：Java类就是一种自定义的数据结构
    E val;                        //数据 ：节点数据 
    ListNode<E> next;             //对象 ：引用下一个节点对象。在Java中没有指针的概念，Java中的引用和C语言的指针类似
    
    ListNode(E val){              //构造方法 ：构造方法和类名相同   
        this.val=val;             //把接收的参数赋值给当前类的val变量
    }
}
```





创建链表及遍历链表：

```java
class ListNode {        //类名 ：Java类就是一种自定义的数据结构
    int val;            //数据 ：节点数据 
    ListNode next;      //对象 ：引用下一个节点对象。在Java中没有指针的概念，Java中的引用和C语言的指针类似
    
    ListNode(int val){  //构造方法 ：构造方法和类名相同   
        this.val=val;   //把接收的参数赋值给当前类的val变量
    }
}

class Test{
    public static void main(String[] args){
        
        ListNode nodeSta = new ListNode(0);    //创建首节点
        ListNode nextNode;                     //声明一个变量用来在移动过程中指向当前节点
        nextNode=nodeSta;                      //指向首节点

        //创建链表
        for(int i=1;i<10;i++){
            ListNode node = new ListNode(i);  //生成新的节点
            nextNode.next=node;               //把心节点连起来
            nextNode=nextNode.next;           //当前节点往后移动
        } //当for循环完成之后 nextNode指向最后一个节点，
        
        nextNode=nodeSta;                     //重新赋值让它指向首节点
        print(nextNode);                      //打印输出
      
    }
    
    //打印输出方法
    static void print(ListNode listNoed){
        //创建链表节点
        while(listNoed!=null){
            System.out.println("节点:"+listNoed.val);
            listNoed=listNoed.next;
        }
        System.out.println();
    }
   
}
```





**链表操作**

删除节点

![image-20210424170534338](https://gitee.com/zhanghui2233/image-storage-warehouse/raw/master/img//image-20210424170534338.png)

 只要将C节点的next指针 指向E节点就可以了。 

 Java 中 有自己的内存回收机制，就不用自己手动释放节点D



添加节点

![image-20210424170704783](https://gitee.com/zhanghui2233/image-storage-warehouse/raw/master/img//image-20210424170704783.png)

可以看出链表的增添和删除都是O(1)操作，也不会影响到其他节点。



**性能分析**

数组在定义的时候，长度就是固定的，如果想改动数组的长度，就需要重新定义一个新的数组。

链表的长度可以是不固定的，并且可以动态增删， 适合数据量不固定，频繁增删，较少查询的场景。



日期：2021年4月28日

###### [移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/)

 给你一个链表的头节点 `head` 和一个整数 `val` ，请你删除链表中所有满足 `Node.val == val` 的节点，并返回 **新的头节点** 。 

 ![img](https://gitee.com/zhanghui2233/image-storage-warehouse/raw/master/img//removelinked-list.jpg) 

```
输入：head = [1,2,6,3,4,5,6], val = 6
输出：[1,2,3,4,5]

输入：head = [], val = 1
输出：[]
```

此题是对单链表删除功能的考察，需要注意的是链表中的头节点问题，如果要删除的元素是链表的头节点，那么需要将头节点的指针指向下一个节点，下一个节点作为整个链表的头节点。如果采用虚拟节点，在链表的头节点之间定义一个虚拟节点，用它来替代头节点，那么删除的时候就不用担心因为节点是头节点而进行额外的处理。





###### [设计链表](https://leetcode-cn.com/problems/design-linked-list/)

 在链表类中实现这些功能： 

```
get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。
addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。
addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。
addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。
deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。
```

多练吧！！！！！



日期：2021年4月28日

###### [反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

 给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表 。

 ![img](https://gitee.com/zhanghui2233/image-storage-warehouse/raw/master/img//rev1ex1.jpg) 

```
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
```

 方法：双指针法和递归方法

双指针法：定义三个指针:pre、curr、tmp、

curr 指向head，pre指向null,

tmp指针作为下一个翻转元素依据点

![image-20210428205323008](https://gitee.com/zhanghui2233/image-storage-warehouse/raw/master/img//image-20210428205323008.png)



###### [删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

 给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。 

 ![img](https://gitee.com/zhanghui2233/image-storage-warehouse/raw/master/img//remove_ex1.jpg) 

```
输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]

输入：head = [1], n = 1
输出：[]
```

方法：双指针法

定义两个指针：fastNode、lowNode

fastNode先走n个单位，之后lowNode才开始走，这时候两个指针同时走，它们差n个距离，当fastNode走到链表尾部，fastNode值为null，lowNode停止移动，此时lowNode的位置就是要删除的位置，可以在lowNode开始移动的时候定义一个指针pre，它记录lowNode每次移动之前上一次的位置。

这里也可以让fastNode走n+1个距离，再让lowNode开始移动，这样lowNode停下来的下一个位置就是要删除的位置。

![image-20210428214106432](https://gitee.com/zhanghui2233/image-storage-warehouse/raw/master/img//image-20210428214106432.png)

![image-20210428214117183](https://gitee.com/zhanghui2233/image-storage-warehouse/raw/master/img//image-20210428214117183.png)





日期：2021年5月7日

###### [环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

给定一个链表，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。

![image-20210507212348702](https://gitee.com/zhanghui2233/image-storage-warehouse/raw/master/img//image-20210507212348702.png)

```
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```



![image-20210507212403675](https://gitee.com/zhanghui2233/image-storage-warehouse/raw/master/img//image-20210507212403675.png)

```
输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。
```

![image-20210507212422221](https://gitee.com/zhanghui2233/image-storage-warehouse/raw/master/img//image-20210507212422221.png)

```
输入：head = [1], pos = -1
输出：false
解释：链表中没有环。
```

思想方法：双指针法

打个比方：乌龟和兔子跑步、乌龟肯定是跑的比兔子慢，假设这是在一个环形跑道上面，兔子先是超越乌龟，之后肯定是可以追上乌龟的。（这就证明了这是一个环形的）

定义两个指针：一个是快指针(兔子)、一个是慢指针(乌龟)

```java
快指针时慢指针速度的两倍
secondNode = secondNode.next;
firstNode = firstNode.next.next;
```

如果要证明链表时环形，只需要证明这两个指针所指向的链表是同一个就可以了。

```java
 while(secondNode != firstNode){
            if(firstNode == null || firstNode.next == null){
                return false;
            }
            secondNode = secondNode.next;
            firstNode = firstNode.next.next;
        }
```





###### [环形链表Ⅱ](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。

说明：不允许修改给定的链表。

![image-20210507213209267](https://gitee.com/zhanghui2233/image-storage-warehouse/raw/master/img//image-20210507213209267.png)

```
输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。
```

这道题目是上一道题目的扩展，通过上一道题目我们知道了如何去判断链表是否是环形的，此题在我们能够判断环形链表的基础上去找到环形链表的环形入口节点。

![image-20210507213402670](https://gitee.com/zhanghui2233/image-storage-warehouse/raw/master/img//image-20210507213402670.png)

假设：

x:表示头节点到环形入口节点的节点数（距离）。

y：表示环形入口节点到fast与slow指针相遇点的节点数（距离）。

z：表示相遇节点到环形入口节点的节点数（距离）。

我们定义fast和slow指针，他们初始的位置都是头节点（head）

```java
  ListNode fast = head;
  ListNode slow = head;
```

slow走过的距离：x+y

fast 走过的距离：x+y+n(z+y)，n表示fast走了n圈才和slow相遇。

环形圈的距离：y+z

fast的速度是slow指针的两倍，因此：

```
fast指针走过的节点数 = slow指针走过的节点数 * 2
(x + y) * 2 = x + y + n (y + z)

两边消掉一个（x+y）: x + y = n (y + z)

根据题目我们要得到的就是x，头节点到环形入口节点的距离。
x = n (y + z) - y 
再从n(y+z)中提出一个 （y+z）来，整理公式之后为如下公式：x = (n - 1) (y + z) + z ，n>=1。
只要是环形链表，fast指针至少要走一圈。

当n = 1 时，带入公式
x = z
这就意味着：从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点。

定义两个指针index1，index2
index1指向head头节点，index2指向fast和slow相遇节点，他们同时向前移动，每次移动一个节点，当他们相遇时就是我们要求解的环形入口节点

```



### 哈希表（ Hash table ）

 哈希表是**根据关键码的值而直接进行访问的数据结构**。

  直白来讲其实数组就是一张哈希表。 

 哈希表中关键码就是数组的索引下表，然后通过下表直接访问数组中的元素，如下图所示： 

![image-20210508201432354](https://gitee.com/zhanghui2233/image-storage-warehouse/raw/master/img//image-20210508201432354.png)

 那么哈希表能解决什么问题呢，**一般哈希表都是用来快速判断一个元素是否出现集合里。** 



##### 哈希函数

 哈希函数如下图所示，通过hashCode把名字转化为数值，一般hashcode是通过特定编码方式，可以将其他数据格式转化为不同的数值，这样就把学生名字映射为哈希表上的索引数字了。 

![image-20210508201653817](https://gitee.com/zhanghui2233/image-storage-warehouse/raw/master/img//image-20210508201653817.png)

如果hashCode得到的数值大于 哈希表的大小了，也就是大于tableSize了，怎么办呢？

此时为了保证映射出来的索引数值都落在哈希表上，我们会在再次对数值做一个**取模**的操作，就要我们就保证了学生姓名一定可以映射到哈希表上了。

此时问题又来了，哈希表我们刚刚说过，就是一个数组。

如果学生的数量大于哈希表的大小怎么办，此时就算哈希函数计算的再均匀，也避免不了会有几位学生的名字同时映射到哈希表 同一个索引下表的位置。

 接下来**哈希碰撞**登场 



##### 哈希碰撞

如图所示，小李和小王都映射到了索引下表 1的位置，**这一现象叫做哈希碰撞**。

![image-20210508201808101](https://gitee.com/zhanghui2233/image-storage-warehouse/raw/master/img//image-20210508201808101.png)

 一般哈希碰撞有两种解决方法， **拉链法**和**线性探测法**。 

###### 拉链法(与链表息息相关)

刚刚小李和小王在索引1的位置发生了冲突，发生冲突的元素都被存储在链表中。 这样我们就可以通过索引找到小李和小王了。

![image-20210508201935591](https://gitee.com/zhanghui2233/image-storage-warehouse/raw/master/img//image-20210508201935591.png)

 （数据规模是dataSize， 哈希表的大小为tableSize） 

 其实拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。 



###### 线性探测法

使用线性探测法，一定要保证tableSize大于dataSize。 我们需要依靠哈希表中的空位来解决碰撞问题。

例如冲突的位置，放了小李，那么就向下找一个空位放置小王的信息。所以要求tableSize一定要大于dataSize ，要不然哈希表上就没有空置的位置来存放 冲突的数据了。如图所示：

![image-20210508202115862](https://gitee.com/zhanghui2233/image-storage-warehouse/raw/master/img//image-20210508202115862.png)

##### 常见的三种哈希结构

- 数组
- set （集合）
- map(映射)



###### Set

- **HashSet类**

- - 它不允许出现重复元素；
  - 不保证集合中元素的顺序
  - 允许包含值为null的元素，但最多只能有一个null元素。
  - HashSet的实现是不同步的。



- **TreeSet类**

- - TreeSet类实现 Set 接口，该接口由 TreeMap 实例支持。此类保证排序后的 set 按照升序排列元素，根据使用的构造方法不同，可能会按照元素的自然顺序 进行排序，或按照在创建 set 时所提供的比较器进行排序。

  - TreeSet描述的是Set的一种变体——可以实现排序等功能的集合，它在将对象元素添加到集合中时会自动按照某种比较规则将其插入到有序的对象序列中.

  - HashSet是基于Hash算法实现的,其性能通常优于TreeSet,我们通常都应该使用HashSet,在我们需要排序的功能时,我门才使用TreeSet;

###### Map接口

- **Hashtable类**

- - Hashtable继承Map接口，实现一个key-value映射的哈希表。任何非空（non-null）的对象都可作为key或者value。
    　　添加数据使用put(key, value)，取出数据使用get(key)，这两个基本操作的时间开销为常数。
  - Hashtable 通过initial capacity和load factor两个参数调整性能。通常缺省的load factor 0.75较好地实现了时间和空间的均衡。增大load factor可以节省空间但相应的查找时间将增大，这会影响像get和put这样的操作。
  - 作为key的对象将通过计算其散列函数来确定与之对应的value的位置，因此任何作为key的对象都必须实现hashCode和equals方法。
  - 　Hashtable是同步的。



- **HashMap类**

- - HashMap和Hashtable类似，不同之处在于HashMap是非同步的，并且允许null，即null value和null key。
    其迭代子操作时间开销和HashMap 的容量成比例,因此，不要将HashMap的初始化容量设得过高，或者load factor过低。

- - **hashmap遍历的两种方式**

  - HashMap的遍历有两种常用的方法，那就是使用keyset及entryset来进行遍历

  - 方法一：

- ```java
     Map map = new HashMap();
        　　     Iterator iter = map.entrySet().iterator();
        　　     while (iter.hasNext()) {
        　　     Map.Entry entry = (Map.Entry) iter.next();
        　　     Object key = entry.getKey();
        　　     Object val = entry.getValue();
        　　}
  ```

- - 效率高,以后尽量要使用此种方式！

    方法二：

- ```java
      Map map = new HashMap();
    　　Iterator iter = map.keySet().iterator();
    　　while (iter.hasNext()) {
    　　Object key = iter.next();
    　　Object val = map.get(key);
    　　}
  ```




- **HashMap的数据结构**

- - HashMap里面实现一个静态内部类Entry，其重要的属性有 key , value, next.
    数据

  - value的值是元素的key的哈希值对数组长度取模得到。如下面第二幅图中，12%16=12,28%16=12,108%16=12,140%16=12。所以12、28、108以及140都存储在数组下标为12的位置。

    ![image-20210508203349218](https://gitee.com/zhanghui2233/image-storage-warehouse/raw/master/img//image-20210508203349218.png)

    ![image-20210508203356744](https://gitee.com/zhanghui2233/image-storage-warehouse/raw/master/img//image-20210508203356744.png)



总结一下，**当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法**。

但是哈希法也是**牺牲了空间换取了时间**，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。

如果在做面试题目的时候遇到需要判断一个元素是否出现过的场景也应该第一时间想到哈希法！





日期：2021年5月8日

##### [有效的异同字母](https://leetcode-cn.com/problems/valid-anagram/)

```
//字母异位词指字母相同，但排列不同的字符串。
```

 给定两个字符串 *s* 和 *t* ，编写一个函数来判断 *t* 是否是 *s* 的字母异位词。 

```
输入: s = "anagram", t = "nagaram"
输出: true
```

```
输入: s = "rat", t = "car"
输出: false
```

哈希法：通过定义一个数组record用来存放26个小写字母（ASCII）,类似于（之前写的上下升降字符串中用到的**桶排法**），先将字符串s字母放入到对应数组中(索引：0-25 ------>a-z),record中记录字母个数，让record记录的字母个数与字符串t中的字母个数相减，如果数组中所有的值都是0，那么这两个字符串是有效异同字母，否则不是。



##### [赎金信](https://leetcode-cn.com/problems/ransom-note/)

给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。

(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)



```
示例 1：

输入：ransomNote = "a", magazine = "b"
输出：false
示例 2：

输入：ransomNote = "aa", magazine = "ab"
输出：false
示例 3：

输入：ransomNote = "aa", magazine = "aab"
输出：true


```

此题和有效异同字母相似，区别在于需要判断magazine中字符串能不能组成ransom中的字符串。



##### [两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays/)

给定两个数组，编写一个函数来计算它们的交集。 



```
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2]

输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[9,4]
```



日期：2021年5月10日



##### [快乐数](https://leetcode-cn.com/problems/happy-number/)

编写一个算法来判断一个数 n 是不是快乐数。

「快乐数」定义为：

对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。
如果 可以变为  1，那么这个数就是快乐数。
如果 n 是快乐数就返回 true ；不是，则返回 false 。

 

```
输入：19
输出：true
解释：
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1



输入：n = 2
输出：false
```



思想：两个关键点。

1.取给定数值的各个位上的数值。

2.判断sum是否重复出现。

第一点：可以同过取余法每次获取各位上的数值，然后除10减一位。比如：

```
123
123 % 10  = 3；	
123 / 10 = 12；

12 % 10 = 2；
12 / 10 = 1；

1 % 10 = 1；
```

第二点：通过Set接口中HashSet实现类判断sum是否重复。





##### [两数之和](https://leetcode-cn.com/problems/two-sum/)

 给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** 的那 **两个** 整数，并返回它们的数组下标。 



```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。

输入：nums = [3,2,4], target = 6
输出：[1,2]

输入：nums = [3,3], target = 6
输出：[0,1]
```

思想：此题需要返回对应数组值和的下标。因此使用HashMap来解决此问题。

![image-20210510193238760](https://gitee.com/zhanghui2233/image-storage-warehouse/raw/master/img//image-20210510193238760.png)

key中存放数组值，value中存放数组索引。

通过循环判断map中是否有key(target - nums[i])的存在，没有就将当前数组的值和索引值加入map中。

![image-20210510193541764](https://gitee.com/zhanghui2233/image-storage-warehouse/raw/master/img//image-20210510193541764.png)

如果存在就返回当前索引值和存在于map中key对应的索引。





日期；2021年5月11日

#####  [ 四数相加 II ](https://leetcode-cn.com/problems/4sum-ii/) 

给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。

为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -228 到 228 - 1 之间，最终结果不会超过 231 - 1 。

 

```
输入:
A = [ 1, 2]
B = [-2,-1]
C = [-1, 2]
D = [ 0, 2]

输出:
2

解释:
两个元组如下:
1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0

```

思想：本题不同于四数之和，不需要考虑重复问题，只需要找出符合题意元组的个数即可，最粗暴方法就不考虑了。此题考虑使用哈希表中的HashMap来解决。

将A、B、C、D四个数组划分为两个大的数组，AB为一组、CD为一组，先计算出AB数组中任意数之和，以及其出现的次数并将其存入HashMap中，key:AB和，value:AB和的数目。

取CD数组中任意数之和的相反数，如果CD数组中任意数之和的相反数存在于HashMap中，那么HashMap中记录的value就代表四数之和为0元组的个数。

```
例如：
HashMap中存放的AB的数组和
key      value
1			1
2			2
3			0
4			1

CD的数组和的数：   -1、-2、-4
CD的数组和的相反数：   1、2、4

总共元组：1+2+1 = 4

```





### 字符串



日期：2021年5月13日

##### [反转字符串](https://leetcode-cn.com/problems/reverse-string/)

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。

不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。



```
输入：["h","e","l","l","o"]
输出：["o","l","l","e","h"]


输入：["H","a","n","n","a","h"]
输出：["h","a","n","n","a","H"]
```

思想：双指针解决，for循环本身作为左指针、定义一个右指针指向数组尾部right = length - 1。

```java
    //另一种方法    
    /* 变量ab作数值交换   
    a = a + b ;    
    b = a - b ;   
    a = a -b ;    
    */        
    //对于数值的交换操作，通常会采用第三个变量作为中间变量过渡的交换方式。   
    //使用这种方法，可以保证交换的准确性，但是由于会使用第三个变量，占用了额外的内存空间。
    /*     char tmp = s[i];           
    	   s[i] = s[right];            
    	   s[right] =tmp;   
           */    
    //使用异或运算    
    /*   	 10 ^ 8 = 2    
    		 10 ^ 8 ^ = 10  
             
    		 s[i] = s[i] ^ s[j];   
             s[j] =  s[j] ^ s[i];//结果得到s[i]    
             s[i] = s[j] ^ s[i];//结果得到s[j]    
    
    */
//时间复杂度:长度为N,整个交换过程只用了N的一半，O(N/2)，
//空间复杂度:是在原来数组的基础上进行的，O(1)
```

 

##### [反转字符串Ⅱ](https://leetcode-cn.com/problems/reverse-string-ii/)

给定一个字符串 s 和一个整数 k，你需要对从字符串开头算起的每隔 2k 个字符的前 k 个字符进行反转。

如果剩余字符少于 k 个，则将剩余字符全部反转。
如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。

```
输入: s = "abcdefg", k = 2
输出: "bacdfeg"
```

思想：核心方法还是双指针，需要判断位于字符串中那些位置的字符需要进行翻转，判断剩余字符的翻转的情况。如果剩余字符都是不小k个的那么，即便剩余字符长度大于2k，还是在k-2k之间,它们要翻转的字符串范围是一样的。





##### [替换空格](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/)

 请实现一个函数，把字符串 `s` 中的每个空格替换成"%20"。 

```
输入：s = "We are happy."
输出："We%20are%20happy."
```

思想：

第一种方法：通过一次for循环遍历 判断空值 ，将空值用%20替换，用StringBuilder做字符串的拼接。（通过建立新的数组来替换空格）

时间复杂度：遍历char数组中的每一个数字，因此O（N）

空间复杂度: 用StringBuilder建立的新的空间，将字符数组中内容加入进来，因此O(N)



第二种方法：在原来的基础上进行扩充，**从后向前**放入字符“%20”，**避免了从前向后放字符导致每次都需要将字符往后移动**。

通过双指针方法，定义一个前指针指向原来数组的末尾，另一个后指针指向扩展之后的数组的末尾。两个指针同时向左移动，当前指针指向空值时，后指针将%20放入数组中，同时后指针向左移动两格，之后两指针再次同时向左移动，依次为条件循环。

时间复杂度：遍历整个字符串s，因此O（N）

空间复杂度: 如果是在c++中，字符串可以扩容通过resize方法，java中字符串定义之后无法改变，我还是定义了新数组，这样在空间和上一个方法的空间复杂度是一样的，O(N)，但是直到了双指针方法怎么去解决这类问题。







##### [翻转字符串里面的单词](https://leetcode-cn.com/problems/reverse-words-in-a-string/)


给定一个字符串，逐个翻转字符串中的每个单词。

**说明：**

- 无空格字符构成一个 **单词** 。
- 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。
- 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。

 

```
示例 1：

输入："the sky is blue"
输出："blue is sky the"
示例 2：

输入："  hello world!  "
输出："world! hello"
解释：输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。
示例 3：

输入："a good   example"
输出："example good a"
解释：如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。
示例 4：

输入：s = "  Bob    Loves  Alice   "
输出："Alice Loves Bob"
示例 5：

输入：s = "Alice does not even like bob"
输出："bob like even not does Alice"

```

思想：通过String方法中trim()方法去除字符串中首位空格，剩下的空格只在字符串里面，StringBuilder和substring 拼接和分割的方法来翻转字符串中的单词。定义两个指针来找到分割单词的范围，start指针和end指针，两个指针同时指向尾部，start先向左移动，当找到空格时，start +1  — end 就是一个单词的范围，通过分割和拼接拿到单词，将start -1 的位置赋给 end ，start指针继续去寻找下一个空格，依次循环直到start< 0 时结束。



日期：2021年5月16日

##### KMP算法

由来： 由这三位学者发明的：Knuth，Morris和Pratt，所以取了三位学者名字的首字母。 

主要应用： **字符串匹配** 。

主要思想：当字符串出现不匹配的时候，根据已经匹配的部分内容，利用这里避免从头再去匹配。

重点就是了解并且能够编写next数组(前缀表)。



**前缀表**(prefix table)

含义:next数组

作用：当字符串出现不匹配时，可以知道下一步该跳到哪里继续进行匹配。



**最长相等前后缀**

前缀：从头开始但不包含尾部的连续子串

后缀：从尾部开始但不包含头的连续子串

```
模式串： a a b a a f
前缀表： 0 1 0 1 2 0
最长相等前后缀值是： 2
```



[Carl 讲解 KMP1](https://www.bilibili.com/video/BV1PD4y1o7nd/)

[Carl 讲解 KMP2](https://www.bilibili.com/video/BV1M5411j7Xx/)

生成前缀表

```java
   /**
     * 前缀表（next数组）
     * 按照前缀表本身，不做减一操作
     *
     * 串下标： 0 1 2 3 4 5
     * 模式串： a a b a a f
     * 前缀表： ? ? ? ? ? ?
     * 前缀：从头开始但不包含尾部的连续子串
     * 后缀：从尾部开始但不包含头的连续子串
     * @param ms
     * @param next
     */
    public static void  getNext(String ms, int[] next){
        //找出前缀表对应数值，根据模式串求出其子串对应的最长相等前后缀的值
        //定义两个指针： i->后缀末端    j->前缀末端  j表示最长相等前后缀的值
        //初始化，对应next数组第一位
        int j = 0 ;
        next[0] = j ;
        for (int i = 1; i < ms.length() ; i++) {
            //前后缀不相等的情况,j需要回退，回退的位置是j的前一位对应的next的值
            while (j>0 && ms.charAt(i) != ms.charAt(j)){
                j= next[j -1 ];
            }
            //前后缀相等的情况下，
            if (ms.charAt(i) == ms.charAt(j)){
                j++;
            }
            next[i] = j;
        }

    }

    /**
     * 前缀表（next数组）
     * 前缀表全部做减一操作
     *
     * 串下标： 0 1 2 3 4 5
     * 模式串： a a b a a f
     * 前缀表： ? ? ? ? ? ?
     * 前缀：从头开始但不包含尾部的连续子串
     * 后缀：从尾部开始但不包含头的连续子串
     * @param ms
     * @param next
     */
    public static void  getNextTwo(String ms, int[] next){
        //找出前缀表对应数值，根据模式串求出其子串对应的最长相等前后缀的值
        //定义两个指针： i->后缀末端    j->前缀末端  j表示最长相等前后缀的值
        //初始化，对应next数组第一位
        int j = -1 ;
        next[0] = j ;
        for (int i = 1; i < ms.length() ; i++) {
            //前后缀不相等的情况,j需要回退
            while (j+1>0 && ms.charAt(i) != ms.charAt(j+1)){
                j= next[j];
            }
            //前后缀相等的情况下，
            if (ms.charAt(i) == ms.charAt(j+1)){
                j++;
            }
            next[i] = j;
        }

    }
```



##### [重复的子字符串](https://leetcode-cn.com/problems/repeated-substring-pattern/)

 给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。 

```
示例 1:

输入: "abab"

输出: True

解释: 可由子字符串 "ab" 重复两次构成。
示例 2:

输入: "aba"

输出: False
示例 3:

输入: "abcabcabcabc"

输出: True

解释: 可由子字符串 "abc" 重复四次构成。 (或者子字abcabc" 重复两次构成。)

```

思想：先将非空字符串对应的前缀表计算出来，其次非空字符互长度减去最长相等前后缀的长度的值 相当于一个周期的长度，周期的长度与非空字符串长度 作余数  如果为 0 ，说明是一个周期循环。



第二种：参考别人的，觉得很神奇，自己想不到/。

链接：https://leetcode-cn.com/problems/repeated-substring-pattern/solution/jian-dan-ming-liao-guan-yu-javaliang-xing-dai-ma-s/

```
如果您的字符串 S 包含一个重复的子字符串，那么这意味着您可以多次 “移位和换行”`您的字符串，并使其与原始字符串匹配。

例如：abcabc

移位一次：cabcab
移位两次：bcabca
移位三次：abcabc

现在字符串和原字符串匹配了，所以可以得出结论存在重复的子串。

基于这个思想，可以每次移动k个字符，直到匹配移动 length - 1 次。但是这样对于重复字符串很长的字符串，效率会非常低。在 LeetCode 中执行时间超时了。

为了避免这种无用的环绕，可以创建一个新的字符串 str，它等于原来的字符串 S 再加上 S 自身，这样其实就包含了所有移动的字符串。

比如字符串：S = acd，那么 str = S + S = acdacd

acd 移动的可能：dac、cda。其实都包含在了 str 中了。就像一个滑动窗口

一开始 acd (acd) ，移动一次 ac(dac)d，移动两次 a(cda)cd。循环结束

所以可以直接判断 str 中去除首尾元素之后，是否包含自身元素。如果包含。则表明存在重复子串。
```

若一个字符串能够由重复的子字符串构成，就具有一定规律，例如  字符串：cnm、cnmcnm

```
 cnm 的移动可能有：nmc、mnc。再来看看cnmcnm字符串中能够由cnm重复组成。
 再来看看内部: 它的内部由nmc和mcn组成，c(nmc)nm、cn(mcn)m，满足这样去除首尾字符的就可以认为能够由子字符串构成。
```





##### [实现 strStr()](https://leetcode-cn.com/problems/implement-strstr/)

给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。

当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。

对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。

```
输入：haystack = "hello", needle = "ll"
输出：2

输入：haystack = "aaaaa", needle = "bba"
输出：-1

输入：haystack = "", needle = ""
输出：0
```

思想：这个问题还是查找字符串匹配问题，此题要求在于返回满足匹配字符串的第一个字符位于原子符的下标。

第一步：先求出needle字符串对应的前缀表。

第二部：for循环遍历haystack字符串与needle字符串做匹配。当满足 

```
 m:needl字符串的长度
 if (j == m){//匹配完成，结束匹配，返回对应原字符串的下标 
                //此题返回needle 字符串出现的第一个位置的下标
                return i - m + 1;
            }
```



### 栈与队列

特点

栈：先进后出

队列：先进先出

![image-20210517203445417](https://gitee.com/zhanghui2233/image-storage-warehouse/raw/master/img//image-20210517203445417.png)

 Stack是继承于Vector(矢量队列)的，由于Vector是通过数组实现的，这就意味着，**Stack也是通过数组实现的**，**而非链表** 。

![image-20210524175100550](https://gitee.com/zhanghui2233/image-storage-warehouse/raw/master/img//image-20210524175100550.png)

 **Stack的构造函数** 

Stack只有一个默认的**构造函数**

```
Stack()
```



 **Stack的API** 

```
             boolean       empty()
synchronized E             peek()
synchronized E             pop()
             E             push(E object)
synchronized int           search(Object o)
```



Stack源码取自： [Java 集合系列07之 Stack详细介绍(源码解析)和使用示例 - 如果天空不死 - 博客园 (cnblogs.com)](https://www.cnblogs.com/skywang12345/p/3308852.html) 

```
package java.util;

public
class Stack<E> extends Vector<E> {
    // 版本ID。这个用于版本升级控制，这里不须理会！
    private static final long serialVersionUID = 1224463164541339165L;

    // 构造函数
    public Stack() {
    }

    // push函数：将元素存入栈顶
    public E push(E item) {
        // 将元素存入栈顶。
        // addElement()的实现在Vector.java中
        addElement(item);

        return item;
    }

    // pop函数：返回栈顶元素，并将其从栈中删除
    public synchronized E pop() {
        E    obj;
        int    len = size();

        obj = peek();
        // 删除栈顶元素，removeElementAt()的实现在Vector.java中
        removeElementAt(len - 1);

        return obj;
    }

    // peek函数：返回栈顶元素，不执行删除操作
    public synchronized E peek() {
        int    len = size();

        if (len == 0)
            throw new EmptyStackException();
        // 返回栈顶元素，elementAt()具体实现在Vector.java中
        return elementAt(len - 1);
    }

    // 栈是否为空
    public boolean empty() {
        return size() == 0;
    }

    // 查找“元素o”在栈中的位置：由栈底向栈顶方向数
    public synchronized int search(Object o) {
        // 获取元素索引，elementAt()具体实现在Vector.java中
        int i = lastIndexOf(o);

        if (i >= 0) {
            return size() - i;
        }
        return -1;
    }
}
```

总结：

 (01) Stack实际上也是通过数组去实现的。
    执行**push**时(即，**将元素推入栈中**)，是通过将元素追加的数组的末尾中。
    执行**peek**时(即，**取出栈顶元素，不执行删除**)，是返回数组末尾的元素。
    执行**pop**时(即，**取出栈顶元素，并将该元素从栈中删除**)，是取出数组末尾的元素，然后将该元素从数组中删除。
(02) Stack继承于Vector，意味着Vector拥有的属性和功能，Stack都拥有。



**Queue**   [参考]( [(30条消息) [Java]Java队列Queue使用详解_devnn的专栏-CSDN博客_java队列queue使用场景](https://blog.csdn.net/devnn/article/details/82591349) )

 Queue的实现类有LinkedList和PriorityQueue。最常用的实现类是LinkedList。 



源码：[参考](https://www.cnblogs.com/CherishFX/p/4608880.html)

```
/**
 * 使用java.util.Queue接口,其底层关联到一个LinkedList（双端队列）实例.
 */
import java.util.LinkedList;
import java.util.Queue;

public class QueueList<E> {
    private Queue<E> queue = new LinkedList<E>();
    
    // 将指定的元素插入此队列（如果立即可行且不会违反容量限制），在成功时返回 true，
    //如果当前没有可用的空间，则抛出 IllegalStateException。
    public boolean add(E e){
        return queue.add(e);
    }
    
    //获取，但是不移除此队列的头。
    public E element(){
        return queue.element();
    }
    
    //将指定的元素插入此队列（如果立即可行且不会违反容量限制），当使用有容量限制的队列时，
    //此方法通常要优于 add(E)，后者可能无法插入元素，而只是抛出一个异常。
    public boolean offer(E e){
        return queue.offer(e);
    }
    
    //获取但不移除此队列的头；如果此队列为空，则返回 null
    public E peek(){
        return queue.peek();
    }
    
    //获取并移除此队列的头，如果此队列为空，则返回 null
    public E poll(){
        return queue.poll();
    }
    
    //获取并移除此队列的头
    public E remove(){
        return queue.remove();
    }
    
    //判空
    public boolean empty() {
        return queue.isEmpty();
    }
}
```



  Queue的6个方法分类： 

压入元素(添加)：**add()、offer()**
**相同**：未超出容量，从队尾压入元素，返回压入的那个元素。
**区别**：在超出容量时，add()方法会对抛出异常，offer()返回false

弹出元素(删除)：**remove()、poll()**
**相同**：容量大于0的时候，删除并返回队头被删除的那个元素。
**区别**：在容量为0的时候，remove()会抛出异常，poll()返回false

获取队头元素(**不删除**)：**element()、peek()**
**相同**：容量大于0的时候，都返回队头元素。但是不删除。
**区别**：容量为0的时候，element()会抛出异常，peek()返回null。



 **Deque**  [参考]( [(30条消息) [Java]Java双端队列Deque使用详解_devnn的专栏-CSDN博客](https://blog.csdn.net/devnn/article/details/82716447) )

 Deque是一个双端队列接口，继承自Queue接口，Deque的实现类是LinkedList、ArrayDeque、LinkedBlockingDeque，其中LinkedList是最常用的。 



 Deque接口扩展(继承)了 Queue 接口。在将双端队列用作队列时，将得到 FIFO（先进先出）行为。将元素添加到双端队列的末尾，从双端队列的开头移除元素。 

| **Queue方法** | **等效Deque方法** |
| :-----------: | :---------------: |
|    add(e)     |    addLast(e)     |
|   offer(e)    |   offerLast(e)    |
|   remove()    |   removeFirst()   |
|    poll()     |    pollFirst()    |
|   element()   |    getFirst()     |
|    peek()     |    peekFirst()    |



 双端队列也可用作 LIFO（后进先出）堆栈。应优先使用此接口而不是遗留 Stack 类。在将双端队列用作堆栈时，元素被推入双端队列的开头并从双端队列开头弹出。堆栈方法完全等效于 Deque 方法，如下表所示： 

| **堆栈方法** | **等效Deque方法** |
| :----------: | :---------------: |
|   push(e)    |    addFirst(e)    |
|    pop()     |   removeFirst()   |
|    peek()    |    peekFirst()    |



日期：2021年5月24日



##### [用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)

请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：

实现 MyQueue 类：

void push(int x) 将元素 x 推到队列的末尾
int pop() 从队列的开头移除并返回元素
int peek() 返回队列开头的元素
boolean empty() 如果队列为空，返回 true ；否则，返回 false

```
输入：
["MyQueue", "push", "push", "peek", "pop", "empty"]
[[], [1], [2], [], [], []]
输出：
[null, null, null, 1, 1, false]

解释：
MyQueue myQueue = new MyQueue();
myQueue.push(1); // queue is: [1]
myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)
myQueue.peek(); // return 1
myQueue.pop(); // return 1, queue is [2]
myQueue.empty(); // return false

```



1.用Stack类实现队列

2.Java堆栈Stack类已经过时，Java官方推荐使用Deque替代Stack使用。Deque堆栈操作方法：push()、pop()、peek()。 



##### [用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)

请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通队列的全部四种操作（push、top、pop 和 empty）。

实现 MyStack 类：

void push(int x) 将元素 x 压入栈顶。
int pop() 移除并返回栈顶元素。
int top() 返回栈顶元素。
boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。



```
输入：
["MyStack", "push", "push", "top", "pop", "empty"]
[[], [1], [2], [], [], []]
输出：
[null, null, null, 2, 2, false]

解释：
MyStack myStack = new MyStack();
myStack.push(1);
myStack.push(2);
myStack.top(); // 返回 2
myStack.pop(); // 返回 2
myStack.empty(); // 返回 False

```



1.使用Queue接口实现

2.使用Deque接口实现，继承自Queue接口，对应Queue接口addLast(e)  offer(e)  offerLast(e)  remove()  removeFirst()  poll()  pollFirst()  element()  getFirst()  peek()  peekFirst()。

```java
    //出入队列：用作元素的出栈和入栈操作
    Queue<Integer> queue ;
    //备份队列:存放不需要出栈的元素
    Queue<Integer> queue1 ;


    Deque<Integer> deque ;
    Deque<Integer> deque1 ;

    /** Initialize your data structure here. */
    public MyStack() {
        queue = new LinkedList<>();
        queue1 = new LinkedList<>();

        deque = new LinkedList<>();
        deque1 = new LinkedList<>();
    }

    /**
     * 例如: 在双队列实现的栈中依次 加入元素 1 2 3 过程
     * queue1 : 1
     * queue : null
     * 交换
     * queue : 1
     * queue : null
     *
     * queue1 : 2
     * queue : 1
     * 备份
     * queue1 : 2 1
     * queue : null
     * 交换
     * queue : 2 1
     * queue1 : null
     *
     *
     * queue1 : 3
     * queue : 2 1
     * 备份
     * queue1 : 3 2 1
     * queue : null
     * 交换
     * queue : 3 2 1
     * queue1 : null
     *
     * 接着从栈中出栈元素3
     * remove:删除队列头部元素
     * queue : 2 1
     */
    /** Push element x onto stack. */
    public void push(int x) {
        //先放入备份队列中
        //add 将元素压入队列尾部
        queue1.add(x);
        //将出入队列中的元素都给备份队列
        while (!queue.isEmpty()){
            queue1.add(queue.remove());
        }

        //此时出入队列为空,目的是为了和备份列队进行数据交换，将备份队列重制为空
        Queue<Integer> tmpQueue;
        tmpQueue = queue;
        queue = queue1;
        queue1 = tmpQueue;
    }

    /** Removes the element on top of the stack and returns that element. */
    public int pop() {
        return queue.remove();
    }

    /** Get the top element. */
    public int top() {
      return   queue.peek();

    }

    /** Returns whether the stack is empty. */
    public boolean empty() {
        return queue.isEmpty();
    }


    //使用Deque 双端队列完成

    public void push1(int x) {
        //先放入备份队列中
        //add 将元素压入队列尾部
        deque1.addLast(x);
        //将出入队列中的元素都给备份队列
        while (!deque.isEmpty()){
            deque1.addLast(deque.removeFirst());
        }

        //此时出入队列为空,目的是为了和备份列队进行数据交换，将备份队列重制为空
        Deque<Integer> tmpDeque;
        tmpDeque = deque;
        deque = deque1;
        deque1 = tmpDeque;
    }

    /** Removes the element on top of the stack and returns that element. */
    public int pop1() {
        return deque.removeFirst();
    }

    /** Get the top element. */
    public int top1() {
        return   deque.peekFirst();

    }

    /** Returns whether the stack is empty. */
    public boolean empty1() {
        return deque.isEmpty();
    }

```



3.可以使用一个队列来完成一个栈的操作，题目要求是使用两个队列完成,这里做一下拓展。

```java
  //使用一个队列完成一个栈的操作。

    public void push2(int x) {
        onlyDeque.addLast(x);
    }

    /** Removes the element on top of the stack and returns that element. */
    public int pop2() {
        //队列元素长度
        int size = onlyDeque.size();
        //将队列中前size - 1 个元素移动到队列尾部，移除对头元素
        int deleteSize = size -1 ;
        while (deleteSize > 0){
            onlyDeque.addLast(onlyDeque.peekFirst());
            onlyDeque.removeFirst();
            deleteSize--;
        }
        return onlyDeque.removeFirst();
    }

    /** Get the top element. */
    public int top2() {
        return   onlyDeque.peekFirst();

    }

    /** Returns whether the stack is empty. */
    public boolean empty2() {
        return onlyDeque.isEmpty();
    }
```



##### [有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。

```
示例 1：

输入：s = "()"
输出：true
示例 2：

输入：s = "()[]{}"
输出：true
示例 3：

输入：s = "(]"
输出：false
示例 4：

输入：s = "([)]"
输出：false
示例 5：

输入：s = "{[]}"
输出：true
```

这道题目主要思想：用栈来判断括号匹配的三个条件，这三个条件是对应匹配无法成立的情况，明白这三个情况之后，这道题目就能够做出来。

```java
    public static boolean isValid(String s) {
        Deque<Character> stringStack = new LinkedList<>();

        char c ;

        for (int i = 0; i < s.length() ; i++) {
            c = s.charAt(i);
            //判断一个左括号如果存在，放入它的右括号到堆栈中
            //比如 : s = "([])";放入栈的之后的元素是: ) ]
            //依次遍历寻找到与栈中 相等的 ) ]，如果相等将其出栈
            if (c == '(' ){
                stringStack.push(')');
            }else  if (c == '[' ){
                stringStack.push(']');
            }else if (c == '{' ){
                stringStack.push('}');
            }else
                //这里判断 括号无法匹配的条件
                //1.左括号多余，导致其找不到对应的右括号,比如：( [] () ,最后导致栈中只有一个 ) ,找不到与之相等右括号。
                //2.中间括号不匹配，比如：( [ } ) ,最后栈中: ) ] ,找不到与之相等的 ) ] ,栈中有剩余。
                //3.右括号多余，比如: () [] ) ,栈中为空,但是最后一个右括号 无法找到相等右括号。
                if (stringStack.isEmpty() || stringStack.peek() != c){
                return false;
            }else {
                //与c 对应相等的情况，也就是右括号与找到了对应匹配的左括号，要作出栈操作。
                stringStack.pop();
            }
        }

        return stringStack.isEmpty();

    }
```



日期：2021年5月25日



##### [删除字符串中所有相邻重复项](https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/)

给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。

在 S 上反复执行重复项删除操作，直到无法继续删除。

在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。



思想：最基本就是一个入栈出栈的操纵，碰到相同的元素，就做出栈操作，如果不相同就做入栈操作，最后将栈中元素出栈做拼接。



```java
    public static String removeDuplicates(String s) {
//        Deque<Character> characterDeque  = new LinkedList<>();
//        int length = s.length();
//        char ch ;
//
//        for (int i = 0; i < length ; i++) {
//            ch = s.charAt(i);
            //栈实现
//            if ( characterDeque.isEmpty()  || characterDeque.peek() != ch ){
//                characterDeque.push(ch);
//            }else {
//                characterDeque.pop();
//            }
            //队列实现
//            if ( !characterDeque.isEmpty()  && characterDeque.peekLast().equals(ch) ){
//                characterDeque.pollLast();
//            }else {
//                characterDeque.addLast(ch);
//            }
//        }
//
//        StringBuilder reString = new StringBuilder();
//
//       while (!characterDeque.isEmpty()){
//            reString.append(characterDeque.pollFirst());
//        }
//
//        return reString.toString();


//        使用StringBuilder作为栈
        StringBuilder stringBuilder = new StringBuilder();

        int index = -1 ;
        for (int i = 0; i < s.length() ; i++) {
            if (index >= 0 && s.charAt(i) == stringBuilder.charAt(index)){
                stringBuilder.deleteCharAt(index);
                index--;
            }else{
                stringBuilder.append(s.charAt(i));
                index++;
            }
        }

        return stringBuilder.toString();


    }

```



##### [逆波兰表达式]([Loading Question... - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/))

根据 逆波兰表示法，求表达式的值。

有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。

 

说明：

整数除法只保留整数部分。
给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。



```
示例 1：

输入：tokens = ["2","1","+","3","*"]
输出：9
解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9
示例 2：

输入：tokens = ["4","13","5","/","+"]
输出：6
解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6
```



逆波兰表达式：

逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。

平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。
该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。
逆波兰表达式主要有以下两个优点：

去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。
适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。



日期：2021年5月29日

##### [滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/submissions/)

给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。

返回滑动窗口中的最大值。



```
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7

```





```java
    public static int[] maxSlidingWindow(int[] nums, int k) {
        int[] reList = new int[nums.length - k+1];
        if (nums.length == 0 || k == 0){
            return reList;
        }
//
//        //右指针
//        int right  = 0 ;
//        //左指针
//        for (int i = 0; i < reList.length; i++) {
            //个人思路，时间太长了,效率太低
//            right = i + k - 1;
//            max = nums[i];
//            int index = i + 1;
//            while (index <= right){
//                if (nums[index] > max ){
//                    max = nums[index];
//                }
//                index++;
//            }
//            reList[i] = max;
//            int max =Integer.MIN_VALUE;
//            for (int j = 0; j < k ; j++) {
//                max = Math.max(max, nums[i + j]);
//            }
//            reList[i] = max;
//        }
//        return reList;
        MyQueue myQueue = new MyQueue();
        int index = 0 ;

        //先将滑动窗口 1 3 -1放入队列中
        for (int i = 0; i < k; i++) {
            myQueue.push(nums[i]);
        }
        reList[index++] = myQueue.peek();
        for (int i = k; i < nums.length; i++) {
            //滑动窗口移除最前面的元素，移除是判断该元素是否放入队列
            myQueue.pop(nums[i - k]);
            //滑动窗口加入最后面的元素
            myQueue.push(nums[i]);
            //记录对应的最大值
            reList[index++] = myQueue.peek();
        }
        return reList;

    }

    /**
     * 实现一个单调队列（由大到小），队列插入和删除元素要与滑动窗口一致
     * 要求：
     * 1.pop方法：要求队列出口元素与滑动窗口移出元素一致
     * 2.push方法：要求队列入口元素与滑动窗口加入元素一致
     * 3.peek方法：要求队列出口元素为最大值
     */
    static class MyQueue{

        Deque<Integer> deque = new LinkedList<>();

        //判断滑动窗口移出元素是否和队列出口元素一致
        void  pop(int val){
            if (!deque.isEmpty() && deque.peekFirst() == val){
                deque.pollFirst();
            }
        }

        //最为核心部分，决定着队列中元素排列顺序
        //比如:
        //滑动窗口 : 1 3 -1
        //队列加入（由大到小）: 3 -1
        //实现：按照一般顺序队列中先加入 1 ,接着加入 3 ，我们需要的是最大值，因此比3小的可以弹出队列，此时队列 3，
        //然后下一个元素是 -1 ，此时入口元素为3，就将-1 加入。 这时滑动窗口中最大元素是3，我们直接弹出出口元素
        //也就是说：如果添加的元素大于入口元素，就将入口元素移出，如果小于等于入口元素,加入到队列
        //随着窗口的移动发生变化由原来: 1 3 -1 变为 ：3 -1 -3。
        //移出的元素 1 ，新加入的元素-3
        //滑动窗口：3 -1 -3，  队列： 3 -1
        //新元素加入：-3 < -1 ,因此加入队列
        //队列： 3 -1 -3，最大元素是3
        //滑动窗口： -1 -3 5
        //新元素加入： 5  ，因此依次弹出-3 、 -1 、 3
        //队列： 5.最大值是5
        //以此类推
        void push(int val){
            while (!deque.isEmpty() && val >deque.peekLast()){
                deque.pollLast();
            }
            deque.addLast(val);
        }

        int peek(){
            return deque.peekFirst();
        }

    }
```





日期：2021年5月30日





### 二叉树

性质：

（n结点个数）

1. n = 0 时，二叉树为空。

2. n>0, 由根结点和根结点下的子结点构成，子节点分为：左子树和右子树。左子树和右子树分别又可以拥有各自的结点。非叶子节点最多可以拥有2个孩子结点。

3. 二叉树的孩子节点(**叶子结点**)成为：左孩子和右孩子。

4.  二叉树的五种形态： 

   ![image-20210530150350943](https://gitee.com/zhanghui2233/image-storage-warehouse/raw/master/img//image-20210530150350943.png)

5. 度：结点所拥有的子树个数。二叉树每个结点最多拥有两个子树(左子树和右子树),因此不存在度大于2的结点。

   

   二叉树中主要的两种形式：满二叉树、完全二叉树。


#### 满二叉树

满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。 

![image-20210530150837078](https://gitee.com/zhanghui2233/image-storage-warehouse/raw/master/img//image-20210530150837078.png)

性质：深度为k，结点数为：2的k次幂 -1 

比如上图：深度为：4 ， 结点数为：15。





#### 完全二叉树

除了最后一层结点可能没有填满外，其余每层结点数目都到达了最大值，并且最后一层结点都集中在最左边的位置。（一定要有左孩子，如果只有右孩子就不是完全二叉树）

说白了就是结点从左到右是连续的。

若最后一层为第h层，最后一层结点数目范围： 1 —  2的h次幂 - 1。

![image-20210530151703418](https://gitee.com/zhanghui2233/image-storage-warehouse/raw/master/img//image-20210530151703418.png)



#### 二叉搜索树

当二叉树中存入了数值，就有了搜索的意义，成了二叉搜索树，它也是一个有序树。

- 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
- 它的左、右子树也分别为二叉排序树

![image-20210530152400510](https://gitee.com/zhanghui2233/image-storage-warehouse/raw/master/img//image-20210530152400510.png)





#### 平衡二叉搜索树

 平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树。

且具有以下性质：它是一棵空树或它的左右两个子树的高度差的**绝对值**不超过1，并且左右两个子树都是一棵平衡二叉树。 



[参考](https://www.cnblogs.com/jianglinliu/p/11197715.html)

理解一下树中**高度**和**深度**的区别 （这里定义高度和深度初始为1）

 **深度**是**从上到下数**的，而**高度**是**从下往上**数。 



平衡因子： 就是任意结点左子树的高度减去右子树的高度。 

![image-20210531194119081](https://gitee.com/zhanghui2233/image-storage-warehouse/raw/master/img//image-20210531194119081.png)

第三个树就不是平衡二叉搜索树，根结点10的平衡因子为2 >1。



#### **二叉树的存储方式**

分为：**链式**存储和**顺序**存储

链式存储使用指针，数据存放在不连续的存储空间中，它们之间通过指针连接起来。

顺序存储使用数组，数据存放在连续的存储空间中，通过索引标注存储的位置。

![image-20210531194726813](https://gitee.com/zhanghui2233/image-storage-warehouse/raw/master/img//image-20210531194726813.png)

类似链表的结构，是以二叉树的形式。



顺序存储图

![image-20210531194814154](https://gitee.com/zhanghui2233/image-storage-warehouse/raw/master/img//image-20210531194814154.png)

 **如果父节点的数组下表是i，那么它的左孩子就是i \* 2 + 1，右孩子就是 i \* 2 + 2。** 

比如： 

```
i= 0 左孩子下标对应：1 ， 右孩子下标对应：2 
i= 1 左孩子下标对应：3 ， 右孩子下标对应：4 
```

一般都使用链式存储的结构表示二叉树，更有利于我们自身的理解。



#### 二叉树的遍历方式

二叉树主要有两种遍历方式：

1. **深度优先**遍历：先往深走，遇到叶子节点再往回走。
2. **广度优先**遍历：一层一层的去遍历。

注： **这两种遍历是图论中最基本的两种遍历方式** 。

 那么从深度优先遍历和广度优先遍历进一步拓展，才有如下遍历方式： 

- 深度优先遍历
  - 前序遍历（递归法，迭代法）
  - 中序遍历（递归法，迭代法）
  - 后序遍历（递归法，迭代法）
- 广度优先遍历
  - 层次遍历（迭代法）



三种遍历方式的顺序

- 前(根)序遍历 (根左右)
- 中(根)序遍历 (左根右)
- 后(根)序遍历 (左右根)



练练手

![image-20210531200605899](https://gitee.com/zhanghui2233/image-storage-warehouse/raw/master/img//image-20210531200605899.png)

前序：5 4 1 2 6 7 8

中序：1 4 2 5 7 6 8

后续：1 2 4 7 8 6 5



 二叉树中深度优先和广度优先遍历实现方式 

 经常会使用**递归**的方式来实现**深度优先遍历**，也就是实现**前中后序遍历**，使用递归是比较方便的。 

 **栈其实就是递归的一种是实现结构**，也就说前中后序遍历的逻辑其实都是可以借助栈使用非递归的方式来实现的。 



 **广度优先遍历**的实现一般使用**队列**来实现，这也是队列**先进先出**的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。 



二叉树定义：

```java
//定义二叉树
public class TreeNodeDefined<E> {
    //数据域
    private E element;
    //左子树
    private TreeNodeDefined<E> leftTree;
    //右子树
    private TreeNodeDefined<E> rightTree;
    
    public TreeNodeDefined(E element){
        this.element = element;
    }

    public TreeNodeDefined(E element, TreeNodeDefined<E> leftTree,TreeNodeDefined<E> rightTree){
        this.element = element;
        this.rightTree = leftTree;
        this.rightTree = rightTree;
    }

    public E getElement(){
        return element;
    }

    public void setElement(E element){
        this.element = element;
    }


    public TreeNodeDefined<E> getLeftTree(){
        return leftTree;
    }

    public void setLeftTree(TreeNodeDefined<E> leftTree){
        this.leftTree = leftTree;
    }

    public TreeNodeDefined<E> getRightTree(){
        return rightTree;
    }

    public void setRightTree(TreeNodeDefined<E> rightTree){
        this.rightTree = rightTree;
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;

        result = prime * result + ((element == null ) ? 0 :element.hashCode());
        result = prime * result + ((rightTree == null ) ? 0 :rightTree.hashCode());
        result = prime * result + ((leftTree == null ) ? 0 :leftTree.hashCode());

        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj){
            return true;
        }
        if (this == null){
            return  false;
        }
        if (getClass() != obj.getClass()){
            return false;
        }
        TreeNodeDefined<?> other = (TreeNodeDefined<?>) obj;
        if (element == null) {
            if (other.element != null){
                return false;
            }
        } else if (!element.equals(other.element)){
            return false;
        }
        if (leftTree == null) {
            if (other.leftTree != null){
                return false;
            }
        } else if (!leftTree.equals(other.leftTree)){
            return false;
        }
        if (rightTree == null) {
            if (other.rightTree != null){
                return false;
            }
        } else if (!rightTree.equals(other.rightTree)) {
            return false;
        }

        return true;
    }
}
```





##### 二叉树的递归遍历（ **前后中序的递归写法** ）

递归算法的三要素：

1.  **确定递归函数的参数和返回值** 

     确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。 

2.  **确定终止条件** 

     写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。 

3.  **确定单层递归的逻辑** 

    确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。 



```java
//递归方法

public class FrontMiddleBeforeTraverse<E>  implements LinkedDoubleTree<E>{
    //根结点
    private TreeNodeDefined<E> root;

    //二叉树结点的链式存储结构
    private List<TreeNodeDefined> nodeDefinedList = null;

    public FrontMiddleBeforeTraverse(){

    }

    public FrontMiddleBeforeTraverse(TreeNodeDefined<E>  root){
        this.root = root;
    }


    @Override
    public void FrontTraverse(TreeNodeDefined<E> node) {
        //顺序：根左右
        //终止的条件
        if (node == null){
            return;
        }
        //先走根结点，打印到控制台
        System.out.println(node.getElement());
        //递归到下一个结点的左子树
        FrontTraverse(node.getLeftTree());
        //递归到下一个结点的右子树
        FrontTraverse(node.getRightTree());
    }

    @Override
    public void MiddleTraverse(TreeNodeDefined<E> node) {
         //顺序：左根右
        //终止的条件
        if (node == null){
            return;
        }
        //先走最底部的左子树
        MiddleTraverse(node.getLeftTree());
        //当左子树遍历完，就到左子树对应的父结点
        System.out.println(node.getElement());
        MiddleTraverse(node.getRightTree());
    }

    @Override
    public void BeforeTraverse(TreeNodeDefined<E> node) {
        //顺序：左右根
        //终止的条件
        if (node == null){
            return;
        }
        BeforeTraverse(node.getLeftTree());
        BeforeTraverse(node.getRightTree());
        System.out.println(node.getElement());
    }
}



补充：迭代法(显示的用栈来实现)
    
        /**
     * 迭代法实现
     * 前序遍历
     *
     * @param root
     */
    public void FrontTraverse(TreeNodeDefined root) {
        Deque<TreeNodeDefined> deque = new LinkedList<>();
//        List<Integer> retList =new ArrayList<>();
        if (root.getElement() == null){

            return ;

        }

        //根结点,先入栈
        deque.push(root);
//        retList.add((Integer) root.getElement());

        while (!deque.isEmpty()){
            //根结点要出栈,栈空，需要知道根节点之后的左右子树,
            TreeNodeDefined node = deque.pop();
            System.out.println(node.getElement());
             //为什么要先加入 右孩子，再加入左孩子呢？因为这样出栈的时候才是中左右的顺序。
            //栈：先入后出
            if (node.getRightTree() != null){
                deque.push(node.getRightTree());
//                retList.add((Integer) node.getRightTree().getElement());
            }
            if (node.getLeftTree() != null){
                deque.push(node.getLeftTree());
//                retList.add((Integer) node.getLeftTree().getElement());
            }
        }

//        return  retList;
    }


    /**
     * 中序遍历
     * 迭代法
     *
     *                 5
     *       4                   6
     *  1         2
     *
     * 结果：1 4 2 5 6
     * @param node
     */
    public void MiddleTraverse(TreeNodeDefined node) {

        //创建栈
        Deque<TreeNodeDefined> deque = new LinkedList<>();



        while (node!=null || !deque.isEmpty()){
            if (node != null){
                deque.push(node);
                node = node.getLeftTree();
            }else{
                //先找到最左的叶子结点
                //出栈
                TreeNodeDefined nodeDefined =  deque.pop();
                System.out.println(nodeDefined.getElement());

                //第一次遍历的时候，1结点被弹出栈，按照中序遍历下一个是4,这里node结点为null（1是叶子节点）
                node = nodeDefined.getRightTree();



            }
        }


    }


    /**
     * 后序遍历
     * @param root
     */
    public void BeforeTraverse(TreeNodeDefined root) {
        //创建栈
        Deque<TreeNodeDefined> deque = new LinkedList<>();


        TreeNodeDefined prev = null;

        while (root != null || !deque.isEmpty()){
            //将左子树加入栈中，直到树中最底部的左子树
            //除了加入左子树，右子树也会加入
            while (root != null){
                deque.push(root);
                root = root.getLeftTree();
            }

            //根据后序遍历的顺序，弹出最底层的左子树
            root = deque.pop();

            //判断节点是否有右子树
            //root.getRightTree() == prev 防止进入死循环，还是拿中序遍历的二叉树来说
            //比如： 2 是 4 结点 的右子树，2 已经 做过了入栈和出栈操作，下一次出栈应该是4，root结点记录了4结点的右子树2，
            //缺少这个条件，2又进入了入栈和出栈的操作， 造成了死循环。
            if (root.getRightTree() == null || root.getRightTree() == prev){
                System.out.println(root.getElement());

                //记录上一次弹出栈的结点
                prev = root;


                //防止root中的结点再次入栈，
                root = null;

            }else {
                //存在右子树，将根节点和其右子树入栈
                deque.push(root);
                //root 不为 null ,下一次做while循环中的入栈操作
                root = root.getRightTree();
            }
            
            
        //另一种写法
        //先序遍历：中左右
        //后序遍历：左右中
        // 中左右 -> 中右左 ->（反置） ->左右中
        Deque<TreeNodeDefined> deque = new LinkedList<>();
        if (root.getElement() == null){

            return ;

        }

        //根结点,先入栈
        deque.push(root);

        while (!deque.isEmpty()){
            //根结点要出栈,栈空，需要知道根节点之后的左右子树,
            TreeNodeDefined node = deque.pop();
            System.out.println(node.getElement());
            //这里要先加入 左孩子，再加入右孩子
            //栈：先入后出
            if (node.getLeftTree() != null){
                deque.push(node.getLeftTree());
            }
            if (node.getRightTree() != null){
                deque.push(node.getRightTree());
            }

        }

        //最后用数组反置就可以
        //例如： 输入：
        //     *
        //     *      4
        //     *    /   \
        //     *   2     7
        //     *  / \   / \
        //     * 1   3 6   9
        //   按照这个逻辑：得出的序列: 4 7 9 6 2 3 1
        //   反置之后：1 3 2 6 9 7 4

        }
    }
```



日期：2021年6月4日

##### [二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/submissions/)

 给你一个二叉树，请你返回其按 **层序遍历** 得到的节点值。 （即逐层地，从左到右访问所有节点）。 

```
示例：
二叉树：[3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
返回其层序遍历结果：

[
  [3],
  [9,20],
  [15,7]
]

```

层序遍历：按层来，一层一层遍历，返回一个二维数组的结果。

```
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> retList = new ArrayList<>();
        Deque<TreeNode> queue = new LinkedList<>();
        if (root == null){
            return retList;
        }
        queue.addLast(root);

        while (queue.size() != 0){
            List<Integer> resOne = new ArrayList<>();
            //当前队列长度，对应上一层遍历完之后，下一层中结点的数目
            int queueSize = queue.size();

            for (int i = 0; i <queueSize ; i++) {
                root =  queue.pollFirst();
                resOne.add(root.val);
                if (root.left != null){
                    queue.addLast(root.left);
                }
                if(root.right != null){
                    queue.addLast(root.right);
                }
            }
            retList.add(resOne);
        }
        return retList;
    }
```



日期：2021年6月5日

##### [二叉树的层序遍历 Ⅱ](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)

 给定一个二叉树，返回其节点值自底向上的层序遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历 

```
例如：
给定二叉树 [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
返回其自底向上的层序遍历为：

[
  [15,7],
  [9,20],
  [3]
]
```

```java
    /**
     *  二叉树的层序遍历 II
     *
     *  给定一个二叉树，返回其节点值自底向上的层序遍历。
     *  （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）
     *
     *      3
     *    / \
     *   9  20
     *     /  \
     *    15   7
     *
     *    [
     *   [15,7],
     *   [9,20],
     *   [3]
     * ]
     *
     * 方法一
     * 之前是通过队列实现从上到下层序遍历
     * 可以使用栈来完成从下到上的遍历
     *
     * 将每一层结点放入队列中，
     * 抛出每一层 结点到数组中，
     * 将数组放入栈中，
     * 最后遍历栈放入到数组中。
     *
     * 方法二
     * 直接将数组反置输出
     * @param root
     * @return
     */
    public List<List<Integer>> levelOrderBottom(TreeNodeDefined root) {
        List<List<Integer>> retList = new ArrayList<>();
        Deque<TreeNodeDefined> queue = new LinkedList<>();
        Deque<List<Integer>> stack = new LinkedList<>();
        if (root == null){
            return retList;
        }
        queue.addLast(root);

        while (queue.size() != 0){
            List<Integer> resOne = new ArrayList<>();
            //当前队列长度，对应上一层遍历完之后，下一层中结点的数目
            int queueSize = queue.size();

            for (int i = 0; i <queueSize ; i++) {
                root =  queue.pollFirst();
                resOne.add((Integer) root.getElement());
                if (root.getLeftTree() != null){
                    queue.addLast(root.getLeftTree());
                }
                if(root.getRightTree() != null){
                    queue.addLast(root.getRightTree());
                }
            }
            stack.push(resOne);
        }

        //方法一
        while(!stack.isEmpty()){
            retList.add(stack.pop());
        }
        //方法二
        reverse(retList);

        return retList;



    }
```



##### [二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)

 给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。 

```
输入: [1,2,3,null,5,null,4]
输出: [1, 3, 4]
解释:

   1            <---
 /   \
2     3         <---
 \     \
  5     4       <---

```

```java
    /**
     * 二叉树的右视图
     *给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。
     *输入: [1,2,3,null,5,null,4]
     * 输出: [1, 3, 4]
     * 解释:
     *
     *    1            <---
     *  /   \
     * 2     3         <---
     *  \     \
     *   5     4       <---
     *
     * @param root
     * @return
     */
    public List<Integer> rightSideView(TreeNodeDefined root) {
        List<Integer> resOne1 = new ArrayList<>();

        if (root == null){
            return resOne1 ;
        }

        Deque<TreeNodeDefined> queue = new LinkedList<>();
        queue.addLast(root);

        while (!queue.isEmpty()){

            int queueSize = queue.size();
//            resOne1.add((Integer) root.getElement());

            for (int i = 0; i < queueSize ; i++) {
                root = queue.pollFirst();
                if (root.getLeftTree() != null){
                    queue.addLast(root.getLeftTree());
                }

                if (root.getRightTree() != null){
                    queue.addLast(root.getRightTree());
                }
                if (i == queueSize - 1){
                    resOne1.add((Integer)root.getElement());
                }
            }

        }


        return resOne1;
    }
```



##### [二叉树的层平均值](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)

 给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。 

```
输入：
    3
   / \
  9  20
    /  \
   15   7
输出：[3, 14.5, 11]
解释：
第 0 层的平均值是 3 ,  第1层是 14.5 , 第2层是 11 。因此返回 [3, 14.5, 11] 。
```



```java
  /**
     * 二叉树的层平均值
     *
     * 给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。
     * 输入：
     *     3
     *    / \
     *   9  20
     *     /  \
     *    15   7
     * 输出：[3, 14.5, 11]
     * 解释：
     * 第 0 层的平均值是 3 ,  第1层是 14.5 , 第2层是 11 。因此返回 [3, 14.5, 11] 。
     *
     * 复杂度分析
     *
     * 时间复杂度：O(n)其中 n 是二叉树中的节点个数。
     * 广度优先搜索需要对每个节点访问一次，时间复杂度是 O(n)。
     * 需要对二叉树的每一层计算平均值，时间复杂度是 O(h)，其中 hh 是二叉树的高度，任何情况下都满足 h \le nh≤n。
     * 因此总时间复杂度是 O(n)
     *
     * 空间复杂度：O(n) 其中 nn 是二叉树中的节点个数。空间复杂度取决于队列开销，队列中的节点个数不会超过 n。
     *
     * @param root
     * @return
     */
    public List<Double> averageOfLevels(TreeNodeDefined root) {
        List<Double> resOne1 = new ArrayList<>();

        if (root == null){
            return resOne1 ;
        }

        Deque<TreeNodeDefined> queue = new LinkedList<>();
        queue.addLast(root);

        while (!queue.isEmpty()){

            int queueSize = queue.size();
            double average = 0.0;

            for (int i = 0; i < queueSize ; i++) {
                root = queue.pollFirst();
                average += (double)root.getElement();
                if (root.getLeftTree() != null){
                    queue.addLast(root.getLeftTree());
                }

                if (root.getRightTree() != null){
                    queue.addLast(root.getRightTree());
                }
            }
            resOne1.add(average/queueSize);

        }


        return resOne1;
    }
```



##### [N叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)

给定一个 N 叉树，返回其节点值的*层序遍历*。（即从左到右，逐层遍历）。

树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。

 

**示例 1：**

![img](https://gitee.com/zhanghui2233/image-storage-warehouse/raw/master/img//narytreeexample.png)

```
输入：root = [1,null,3,2,4,null,5,6]
输出：[[1],[3,2,4],[5,6]]
```

```java
/**
     * N 叉树的层序遍历
     *
     * 给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。
     *
     * 树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。
     * @param root
     * @return
     */
    public List<List<Integer>> levelOrder(NTreeNodeDefined root) {
        List<List<Integer>> retList = new ArrayList<>();
        if (root == null){
            return retList;
        }
        Deque<NTreeNodeDefined> queue = new LinkedList<>();
        queue.addLast(root);

        while (!queue.isEmpty()){
            int queueSize =queue.size();
            List<Integer> resOne = new ArrayList<>();

            for (int i = 0; i <queueSize ; i++) {
                root = queue.pollFirst();
                resOne.add(root.getElement());

                List<NTreeNodeDefined> childrenList = root.getChildren();
                if (childrenList.size() != 0){
                    for (int j = 0; j < childrenList.size(); j++) {
                        queue.addLast(childrenList.get(j));
                    }
                }
            }
            retList.add(resOne);

        }

        return retList;
    }
```





##### [在每个树行中找最大值](https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/)

 您需要在二叉树的每一行中找到最大的值。 

```
示例：

输入: 

          1
         / \
        3   2
       / \   \  
      5   3   9 

输出: [1, 3, 9]
```

```java
/**
     *  在每个树行中找最大值
     *
     *      输入:
     *
     *           1
     *          / \
     *         3   2
     *        / \   \
     *       5   3   9
     *
     * 输出: [1, 3, 9]
     * @param root
     * @return
     */
    public List<Integer> largestValues(TreeNodeDefined root) {
        List<Integer> resOne2 = new ArrayList<>();

        if (root == null){
            return resOne2 ;
        }

        Deque<TreeNodeDefined> queue = new LinkedList<>();
        queue.addLast(root);

        while (!queue.isEmpty()){

            int queueSize = queue.size();
            Integer maxValue = Integer.MIN_VALUE;

            for (int i = 0; i < queueSize ; i++) {
                root = queue.pollFirst();
                maxValue = maxValue < (Integer)root.getElement() ? (Integer) root.getElement() : maxValue;
                if (root.getLeftTree() != null){
                    queue.addLast(root.getLeftTree());
                }

                if (root.getRightTree() != null){
                    queue.addLast(root.getRightTree());
                }
            }
            resOne2.add(maxValue);

        }


        return resOne2;
    }
```





##### [填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)

给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。

初始状态下，所有 next 指针都被设置为 NULL。

 ![img](https://gitee.com/zhanghui2233/image-storage-warehouse/raw/master/img//116_sample.png) 

```
输入：root = [1,2,3,4,5,6,7]
输出：[1,#,2,3,#,4,5,6,7,#]
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，'#' 标志着每一层的结束。
```

```java
   /**
     *  填充每个节点的下一个右侧节点指针
     *
     * 输入：root = [1,2,3,4,5,6,7]
     * 输出：[1,#,2,3,#,4,5,6,7,#]
     * 解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，'#' 标志着每一层的结束。
     *
     * @param root
     * @return
     */
    public PerfectTreeNodeDefined connect(PerfectTreeNodeDefined root) {
        if (root == null){
            return root ;
        }

        Deque<PerfectTreeNodeDefined> queue = new LinkedList<>();
        queue.addLast(root);

        while (!queue.isEmpty()){

            int queueSize = queue.size();

            for (int i = 0; i < queueSize ; i++) {
                PerfectTreeNodeDefined nodeDefined = queue.pollFirst();

                if (i < queueSize - 1){
                    nodeDefined.setNext(queue.peekFirst());
                }

                if (nodeDefined.getLeftTree() != null){
                    queue.addLast(nodeDefined.getLeftTree());
                }

                if (nodeDefined.getRightTree() != null){
                    queue.addLast(nodeDefined.getRightTree());
                }
            }

        }


        return root;

    }
```





##### [翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

```
输入：

     4
   /   \
  2     7
 / \   / \
1   3 6   9
输出：

     4
   /   \
  7     2
 / \   / \
9   6 3   1

```

```java
   /**
     *翻转二叉树
     * （递归实现）
     *
     * 输入：
     *
     *      4
     *    /   \
     *   2     7
     *  / \   / \
     * 1   3 6   9
     * 输出：
     *
     *      4
     *    /   \
     *   7     2
     *  / \   / \
     * 9   6 3   1
     *
     * @param root
     * @return
     */
    public TreeNodeDefined invertTree(TreeNodeDefined root) {
        //终止条件 : 当前结点为叶子结点
        if (root == null){
            return root;
        }

        TreeNodeDefined tmp = root.getRightTree();
        root.setRightTree(root.getLeftTree());
        root.setLeftTree(tmp);

        invertTree(root.getLeftTree());

        invertTree(root.getRightTree());

        return root;


    }

    /**
     *翻转二叉树
     * （层序实现）队列
     *
     * 输入：
     *
     *      4
     *    /   \
     *   2     7
     *  / \   / \
     * 1   3 6   9
     * 输出：
     *
     *      4
     *    /   \
     *   7     2
     *  / \   / \
     * 9   6 3   1
     *
     * @param root
     * @return
     */
    public TreeNodeDefined invertTree1(TreeNodeDefined root) {
        //层序遍历
        if (root == null){
            return null;
        }

        Deque<TreeNodeDefined> queue = new LinkedList<>();

        queue.addLast(root);

        while (!queue.isEmpty()){
            root = queue.pollFirst();
            TreeNodeDefined tmp = root.getRightTree();
            root.setRightTree(root.getLeftTree());
            root.setLeftTree(tmp);

            if (root.getLeftTree() != null){
                queue.addLast(root.getLeftTree());
            }
            if (root.getRightTree() != null){
                queue.addLast(root.getRightTree());
            }

        }

        return root;
    }


    /**
     * 翻转二叉树
     * 迭代法(栈)
     * 先序遍历
     * 先
     *
     * 输入：
     *
     *      4
     *    /   \
     *   2     7
     *  / \   / \
     * 1   3 6   9
     * 输出：
     *
     *      4
     *    /   \
     *   7     2
     *  / \   / \
     * 9   6 3   1
     * @param root
     * @return
     */
    public TreeNodeDefined invertTree2(TreeNodeDefined root) {
        //先序遍历
        if (root == null){
            return null;
        }

        Deque<TreeNodeDefined> queue = new LinkedList<>();

        queue.push(root);

        while (!queue.isEmpty()){
            root = queue.poll();
            TreeNodeDefined tmp = root.getRightTree();
            root.setRightTree(root.getLeftTree());
            root.setLeftTree(tmp);


            if (root.getRightTree() != null){
                queue.addLast(root.getRightTree());
            }

            if (root.getLeftTree() != null){
                queue.addLast(root.getLeftTree());
            }

        }

        return root;
    }

```



##### [对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

给定一个二叉树，检查它是否是镜像对称的。 

例如，二叉树 `[1,2,2,3,4,4,3]` 是对称的。

```
    1
   / \
  2   2
 / \ / \
3  4 4  3
```

```java
    /**
     *对称二叉树
     *
     *     1
     *    / \
     *   2   2
     *  / \ / \
     * 3  4 4  3
     *
     * 判断此二叉树是否镜像对称
     *
     * 从根节点出发（根结点不参与判断，根节点只有一个）
     * 根节点下的左子树：left(这里对应 2)，根节点下的右子树：right（对应2）
     * 比较 left 和 right是否相等，不相等直接返回
     * 如果相等并且left和right都有子树，
     * 判断left下的左子树和 right下的右子树是否相等，left下的右子树和right下的左子树是否相等
     *
     * 如果说给的二叉树相对复杂一些，比如
     *
     *              1
     *             / \
     *            2   2
     *           / \ / \
     *          3  4 4  3
     *        / \      / \
     *       5   6    6   5
     *
     * 递归循环过程：
     * 先从2的左节点和 2 的右节点开始向下寻找
     * 找到3 、3 ，再去寻找 3的左节点和3的右节点，也就是 5、5
     * 再去寻找5、5下的左节点和右节点，如果没有返回 都为null ，返回ture
     * 再做5、5下的右节点和左节点的判断，结果都为bull，返回ture，
     * 回到3、3，再去寻找3的右节点和3的左节点，6、6，接下来就和上面一样，
     * 总之先去寻找到最底部，如果底部都满足条件。那么再往上去判断。
     *
     * @param root
     * @return
     */
    public static boolean isSymmetric(TreeNodeDefined root) {
        //递归方法
        if (root == null){
            return  true;
        }


        return compare(root.getLeftTree(),root.getRightTree());
    }


    /**
     * 比较根节点下的两个树
     *   2   2
     *  / \ / \
     * 3  4 4  3
     * @return
     */
    public static boolean compare(TreeNodeDefined leftTree, TreeNodeDefined rightTree){
        //结点为空的情况
        //两个结点都是空的情况
        if (leftTree == null && rightTree == null){
            return true;
        }

        //有一个为空的结点
        if (leftTree == null || rightTree == null){
            return  false;
        }

        //结点不为空的情况
        //两个结点值不相同
        if (leftTree.getElement() != rightTree.getElement()){
            return false;
        }

        //当前两个节点相等
        //(左)当前结点的左节点和(右)当前结点的右结点作比较
        boolean outside =  compare(leftTree.getLeftTree(),rightTree.getRightTree());

        //(左)当前结点右节点和(右)当前结点的左结点作比较
        boolean inside =  compare(leftTree.getRightTree(),rightTree.getLeftTree());

        return outside && inside;


    }


    /**
     *使用队列来完成
     *
     * 从根节点的左右子结点开始
     *
     * 每层中对称结点的左节点、右节点，右节点、左节点依次放入队列中，判断是否一致
     * @param root
     * @return
     */
    public static boolean isSymmetric1(TreeNodeDefined root) {
        //迭代方法
        if (root == null){
            return  true;
        }
        Deque<TreeNodeDefined> queue = new LinkedList<>();

        queue.addLast(root.getLeftTree());
        queue.addLast(root.getRightTree());


        while (!queue.isEmpty()){
            TreeNodeDefined leftTree = queue.pollFirst();
            TreeNodeDefined rightTree = queue.pollFirst();

            //结点为空的情况
            //两个结点都是空的情况
            if (leftTree == null && rightTree == null){
                continue;
            }

            //有一个为空的结点
            if (leftTree == null || rightTree == null){
                return  false;
            }

            //结点不为空的情况
            //两个结点值不相同
            if (leftTree.getElement() != rightTree.getElement()){
                return false;
            }

            queue.addLast(leftTree.getLeftTree());
            queue.addLast(rightTree.getRightTree());

            queue.addLast(leftTree.getRightTree());
            queue.addLast(rightTree.getLeftTree());



        }



        return true;
    }
```





##### [二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。

示例：
给定二叉树 [3,9,20,null,null,15,7]，

```
    3
   / \
  9  20
    /  \
   15   7
```

返回它的最大深度 3 。

```java
    /**
     *二叉树的最大深度
     * (递归)
     *
     * 给定一个二叉树，找出其最大深度。
     *
     * 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。
     *
     * 说明: 叶子节点是指没有子节点的节点。
     *
     * *
     *      *              1
     *      *             / \
     *      *            2   2
     *      *           / \ / \
     *      *          3  4 4  3
     *
     *和判断二叉树 对称类似，都是从根节点出发，将其左节点和右节点当成两个二叉树来看，递归遍历去查找深度
     * @param root
     * @return
     */
    public static int maxDepth(TreeNodeDefined root) {
        if (root == null){
            return 0;
        }else{
            int leftHeight= maxDepth(root.getLeftTree());
            int rightHeight= maxDepth(root.getRightTree());
            //加一的原因是从根节点开始，将他的左结点和右结点看成两个二叉树，求出深度最大的，最后加上根节点算出整个树的深度
            return Math.max(leftHeight,rightHeight)+1;
        }
    }


    /**
     * 迭代法
     * @param root
     * @return
     */
    public static int maxDepth1(TreeNodeDefined root) {

        //层序遍历（队列）
        if (root == null){
            return 0;
        }
        Deque<TreeNodeDefined> queue = new LinkedList<>();

        int deep = 0 ;

        queue.addLast(root);

        while (!queue.isEmpty()) {
            int queueSize = queue.size();

            for (int i = 0; i <queueSize ; i++) {
                root = queue.pollFirst();
                if (root.getLeftTree() != null){
                    queue.addLast(root.getRightTree());
                }
                if (root.getRightTree() != null){
                    queue.addLast(root.getRightTree());
                }
            }

            deep++;



        }

        return deep;



    }

```



##### [二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

**说明：**叶子节点是指没有子节点的节点。

**示例 1：**

<img src="https://gitee.com/zhanghui2233/image-storage-warehouse/raw/master/img//ex_depth.jpg" alt="img" style="zoom:50%;" />

```
输入：root = [3,9,20,null,null,15,7]
输出：2
```

```java
    /**
     * 二叉树的最小深度
     * (递归)
     *
     * 给定一个二叉树，找出其最小深度。
     *
     * 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。
     *
     * 说明：叶子节点是指没有子节点的节点。
     *
     * 注意：如果根节点的左结点或右结点为空时，最小深度并不是结点为空的深度，反而是结点不为空之下距离根节点最近的叶子结点的深度。
     * 因此需要判断结点为空情况。
     *
     *
     *               1
     *              /
     *             2
     *            / \
     *           4  3
     * @param root
     * @return
     */
    public static int minDepth(TreeNodeDefined root) {
        if (root == null){
            return 0;
        }

        int leftHeight = minDepth(root.getLeftTree());
        int rightHeight = minDepth(root.getRightTree());

        //左结点为空情况
        if (root.getLeftTree() == null && root.getRightTree() != null){
            return  rightHeight+1;
        }

        //右节点为空情况
        if (root.getRightTree() == null && root.getLeftTree() != null){
            return leftHeight+1;
        }

        return Math.min(leftHeight,rightHeight)+1;


    }

    /**
     * 层序遍历
     *
     * 使用队列完成
     * @param root
     * @return
     */
    public static int minDepth2(TreeNodeDefined root) {
        if (root == null){
            return 0;
        }

        int depth = 0;
        Deque<TreeNodeDefined> queue = new LinkedList<>();
        queue.addLast(root);
        depth = 1;

        while (!queue.isEmpty()){
            int queueSize = queue.size();

            for (int i = 0; i <queueSize ; i++) {
                root = queue.pollFirst();
                //层序遍历.如果当前层出现左右结点都是空那么返回层数
                if (root.getLeftTree() == null && root.getRightTree() == null){
                    return depth;
                }
                if (root.getLeftTree() != null){
                    queue.addLast(root.getLeftTree());
                }
                if (root.getRightTree() != null){
                    queue.addLast(root.getRightTree());
                }
            }
            depth++;

        }

        return depth;

    }
```



##### [完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)

给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。

完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。

 ![img](https://gitee.com/zhanghui2233/image-storage-warehouse/raw/master/img//complete.jpg) 

```
输入：root = [1,2,3,4,5,6]
输出：6
```

```java
    /**
     * 给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。
     *
     * 完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。
     *
     *  
     * (递归法)
     * @param root
     * @return
     */
    public int countNodes(TreeNodeDefined root) {
        if (root == null) {
            return 0;
        }

        int nodeNumberLeft = countNodes(root.getLeftTree());

        int nodeNumberRight = countNodes(root.getRightTree());

        return nodeNumberLeft + nodeNumberRight + 1 ;

    }


    /**
     * 迭代法
     * 层序遍历
     * 队列
     * @param root
     * @return
     */
    public int countNodes1(TreeNodeDefined root) {
        if (root == null) {
            return 0;
        }
        int nodeNumber = 0;

        Deque<TreeNodeDefined> queue = new LinkedList<>();
        queue.addLast(root);

        while (!queue.isEmpty()){
            int queueSize = queue.size();
            nodeNumber += queueSize;

            for (int i = 0; i < queueSize; i++) {
                root = queue.pollFirst();

                if (root.getLeftTree() != null){
                    queue.addLast(root.getLeftTree());
                }

                if (root.getRightTree() != null){
                    queue.addLast(root.getRightTree());
                }
            }
        }

        return nodeNumber;


    }
```



##### [平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。

 

示例 1：

 ![img](https://gitee.com/zhanghui2233/image-storage-warehouse/raw/master/img//balance_1.jpg) 

```
输入：root = [3,9,20,null,null,15,7]
输出：true
```

```java
    /**
     *平衡二叉树·
     * 递归（后序遍历）左右中
     *
     * 一棵高度平衡二叉树定义为：
     *
     * 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。
     */
    public boolean isBalanced(TreeNodeDefined root) {
        //-1：作为判断是否为二叉树的依据
        //-1:表示左右子树的高度差的绝对值大于1 ---> false
        return getDepth(root) != -1;
    }


    public int getDepth(TreeNodeDefined root){
        //当前结点为null，返回0
        if (root == null){
            return  0;
        }

        int leftHeight = getDepth(root.getLeftTree());
        //当返回的结点的高度为-1时，表明已经不是平衡二叉树
        if (leftHeight == -1){
            return -1;
        }
        int rightHeight = getDepth(root.getRightTree());
        if (rightHeight == -1){
            return -1;
        }


        //判断每层中左右子树的高度差
        if (Math.abs(leftHeight - rightHeight) > 1){
            //返回-1，表明当前高度差绝对值超过1，此树不是平衡二叉树
            return  -1;
        }

        return Math.max(leftHeight,rightHeight)+1;

    }


    /**
     * 迭代法
     * 层序遍历适合求深度从上到下，因此此题不适用
     *
     * 定义栈，使用后序遍历来完成
     * @param root
     * @return
     */
    public boolean isBalanced1(TreeNodeDefined root) {

        if (root == null){
            return  true;
        }

        Deque<TreeNodeDefined> stack = new LinkedList<>();
        TreeNodeDefined prev = null;


        while (!stack.isEmpty() || root != null){
            while (root != null){
                stack.push(root);
                root = root.getLeftTree();
            }

            root = stack.peek();

            if (root.getRightTree() == null || root.getRightTree() == prev){

                if (Math.abs(getDepth1(root.getLeftTree()) - getDepth1(root.getRightTree())) > 1){
                    return false;
                }

                stack.pop();

                prev = root;

                root = null;

            }else{
                root =  root.getRightTree();
            }

        }

        return true;

    }
```



##### [二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)

给定一个二叉树，返回所有从根节点到叶子节点的路径。

说明: 叶子节点是指没有子节点的节点。

示例:

输入:

   1
 /   \
2     3
 \
  5

输出: ["1->2->5", "1->3"]

解释: 所有根节点到叶子节点的路径为: 1->2->5, 1->3

```java
   /**
     *  二叉树的所有路径
     *递归 （前序遍历）
     *     1
     *  /   \
     * 2     3
     *  \
     *   5
     *
     * 输出: ["1->2->5", "1->3"]
     *
     * 解释: 所有根节点到叶子节点的路径为: 1->2->5, 1->3
     *
     * 判断路径条件：当前结点为叶子结点(没有左子节点和右子节点)
     *
     * 定义一个List数组用来存放走过的结点路径
     *
     * 当递归到叶子节点时，表示到达当前路径的尾部，
     * 拼接出路径，从叶子节点一层一层回溯到根节点并且把存放结点路径的List在回溯的过程中清空
     */

    public List<String> binaryTreePaths(TreeNodeDefined root) {
        List<String> res = new ArrayList<>();
        if (root == null){
            return  res;
        }

        //存放结点路径的数组
        List<Integer> pathNoe = new ArrayList<>();

        traverse(root,pathNoe,res);

        return res;
    }

    //递归回溯
    public void traverse(TreeNodeDefined root, List<Integer> pathNoe, List<String> res) {
        //每递归一次记录当前结点
        pathNoe.add((Integer) root.getElement());

        //终止条件,当前结点为叶子节点
        if (root.getLeftTree() == null && root.getRightTree() == null){
            StringBuilder stringBuilder = new StringBuilder();
            for (int i = 0; i <pathNoe.size()-1 ; i++) {
                stringBuilder.append(pathNoe.get(i)).append("->");
            }
            stringBuilder.append(pathNoe.get(pathNoe.size() - 1));
            res.add(stringBuilder.toString());
            //路径拼接完成，开始进行回溯
            return;
        }

        if (root.getLeftTree() != null){
            traverse(root.getLeftTree(),pathNoe,res);
            //回溯过程中将结点去除
            pathNoe.remove(pathNoe.size() - 1);
        }

        if (root.getRightTree() != null){
            traverse(root.getRightTree(),pathNoe,res);
            //回溯过程中将结点去除
            pathNoe.remove(pathNoe.size() - 1);
        }
    }


    /**
     * 迭代法
     * 用栈模拟
     * (前序遍历)
     * @param root
     * @return
     */
    public List<String> binaryTreePaths1(TreeNodeDefined root) {
        List<String> res = new ArrayList<>();
        if (root == null){
            return  res;
        }


        Deque<String> pathNoe = new LinkedList<>();
        Deque<TreeNodeDefined> stack = new LinkedList<>();
        pathNoe.push(String.valueOf(root.getElement()));
        stack.push(root);

        while (!stack.isEmpty()){
            TreeNodeDefined node = stack.pop();

            String path = pathNoe.pop();

            if (node.getLeftTree() == null && node.getRightTree() == null){
                res.add(path);
            }

            //栈中模拟前序遍历 先放右孩子
            if (node.getRightTree() != null){
                stack.push(node.getRightTree());
                pathNoe.push( path+"->"+node.getRightTree().getElement());
            }

            if (node.getLeftTree() != null){
                stack.push(node.getLeftTree());
                pathNoe.push(path+"->"+node.getLeftTree().getElement());
            }


        }


        return res;
    }
```



##### [左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/)

计算给定二叉树的所有左叶子之和。

示例：

```
    3
   / \
  9  20
    /  \
   15   7
```

在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24

```java
    /**
     *
     * 递归法
     * 递归三要素：递归函数的参数和返回值、终止条件、单体循环
     * 使用的是后序遍历：左右中
     * 因为要寻找左子树值之和，而左子树需要通过父结点来判断，并且右子树中的子节点可能也有左子树，因此后序遍历的顺序正好顺应了。
     *
     *计算给定二叉树的所有左叶子之和。
     *     3
     *    / \
     *   9  20
     *     /  \
     *    15   7
     *
     在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24
     * @param root
     * @return
     */
    public int sumOfLeftLeaves(TreeNodeDefined root) {
        if (root == null){
            return 0;
        }

        int leftValue = sumOfLeftLeaves(root.getLeftTree());
        int rightValue = sumOfLeftLeaves(root.getRightTree());

        //左叶子节点：节点不为空并且没有左右子节点
        //问题点：root.getElement() != null，这样无法做出判断此节点是左节点还是右节点，因此需要通过父结点来判断
        int value = 0;
        if (root.getLeftTree() != null && root.getLeftTree().getLeftTree() == null && root.getRightTree().getRightTree() == null){
            value = (int) root.getLeftTree().getElement();
        }

        return value + leftValue + rightValue;



    }

    /**
     * 迭代法(前序遍历)
     * @param root
     * @return
     */
    public int sumOfLeftLeaves1(TreeNodeDefined root) {
        Deque<TreeNodeDefined> stack = new LinkedList<>();

        //根节点入栈
        stack.push(root);

        int value = 0;
        while (!stack.isEmpty()){
            TreeNodeDefined node = stack.pop();
            if (node.getLeftTree() != null && node.getLeftTree().getLeftTree() == null && node.getRightTree().getRightTree() == null){
                value = (int) node.getLeftTree().getElement() + value;
            }

            if (node.getRightTree() != null){
                stack.push(node.getRightTree());
            }

            if (node.getLeftTree() != null){
                stack.push(node.getLeftTree());
            }




        }

        return value;
    }

    /**
     * 迭代法(中序遍历)
     * @param root
     * @return
     */
    public int sumOfLeftLeaves2(TreeNodeDefined root) {
        Deque<TreeNodeDefined> stack = new LinkedList<>();
        int value = 0;
        while (!stack.isEmpty() || root != null){
            //放入最底左子树
            if (root != null) {
                stack.push(root);
                root = root.getLeftTree();
            }else{
                //从最左的叶子节点开始
                //出栈
                TreeNodeDefined node = stack.pop();
                if (node.getLeftTree() != null && node.getLeftTree().getLeftTree() == null && node.getRightTree().getRightTree() == null){
                    value = (int) node.getLeftTree().getElement() + value;
                }
                root = node.getRightTree();

            }
        }

        return value;
    }

```





##### [找树左下角的值](https://leetcode-cn.com/problems/find-bottom-left-tree-value/)

给定一个二叉树，在树的最后一行找到最左边的值。

**示例 1:**

```
输入:

    2
   / \
  1   3

输出:
1
```

```java
   /**
     * 层序遍历（非常适用）
     *
     * 给定一个二叉树，在树的最后一行找到最左边的值。
     * 输入:
     *
     *     2
     *    / \
     *   1   3
     *
     * 输出:
     * 1
     * @param root
     * @return
     */
    public int findBottomLeftValue(TreeNodeDefined root) {
        Deque<TreeNodeDefined> queue = new LinkedList<>();
        if (root == null){
            return  0 ;
        }

        queue.addLast(root);

        int value = 0;
        while (queue.size() != 0){
            int queueSize = queue.size();
            for (int i = 0; i < queueSize; i++) {
                root = queue.pollFirst();
                if (i == 0) {
                    value = (int) root.getElement();
                }
                if (root.getLeftTree() !=null){
                    queue.addLast(root.getLeftTree());
                }
                if (root.getRightTree() !=null){
                    queue.addLast(root.getRightTree());
                }
            }
        }
        return value;

    }

    /**
     * 递归
     *（前序遍历）
     * 先找到二叉树的最大深度，再去寻找最左子树的值
     *
     * @param root
     * @return
     */
    //全局最大深度
    private int maxDeep = -1;
    //全局最左子树
    int leftValue = 0;

    public int findBottomLeftValue1(TreeNodeDefined root) {
        //根节点出发
        leftValue = (int) root.getElement();
        //根节点出发，从深度1开始
        findLeftValue(root,1);
        return leftValue;


    }

    private void findLeftValue(TreeNodeDefined root, int deep) {
        //当节点为叶子节点时
        if (root.getLeftTree() == null && root.getRightTree() == null){
            //判断最大深度
            if (deep > maxDeep){
                //更新最左子树
                leftValue = (int) root.getElement();
                maxDeep = deep;
            }
        }

        if (root.getLeftTree() != null){
            //深度加1
            findLeftValue(root.getLeftTree(),deep+1);
        }

        if (root.getRightTree() != null){
            //深度加1
            findLeftValue(root.getRightTree(),deep+1);
        }
    }
```





##### [路径总和](https://leetcode-cn.com/problems/path-sum/)

给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。

叶子节点 是指没有子节点的节点。

 <img src="https://gitee.com/zhanghui2233/image-storage-warehouse/raw/master/img//pathsum1.jpg" alt="img" style="zoom:50%;" />



输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
输出：true

```java
   /**
     * 112. 路径总和
     * 给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，
     * 判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。
     *
     * 叶子节点 是指没有子节点的节点。
     *
     * 通过从根节点开始和targetSum的值做减法操作，当到达叶子结点时，如果targetSum为0，那么存在根节点到叶子节点 的路径，
     * 如果不为0，那么这条路径不存在。
     * 递归法
     * @param root
     * @param targetSum
     * @return
     */
    public boolean hasPathSum(TreeNodeDefined root, int targetSum) {
        if (root == null){
            return false;
        }

        targetSum -= (int)root.getElement();

        //到达叶子结点
        if (root.getLeftTree() == null && root.getRightTree() == null){

            if (targetSum == 0){
                return true;
            }else {
                return false;
            }
        }

        if (root.getLeftTree() != null){
            boolean left =hasPathSum(root.getLeftTree(),targetSum);
            //left为true表明找到了该路径
            if (left){
                return true;
            }
        }

        if (root.getRightTree() != null){
            boolean right =hasPathSum(root.getLeftTree(),targetSum);
            //right为true表明找到了该路径
            if (right){
                return true;
            }
        }

        return false;
    }

    /**
     * 层序遍历
     *
     * @param root
     * @param targetSum
     * @return
     */
    public boolean hasPathSum1(TreeNodeDefined root, int targetSum) {
        if (root == null){
            return false;
        }

        Deque<TreeNodeDefined> queueNode = new LinkedList<>();
        Deque<Integer> queueValue = new LinkedList<>();
        queueNode.addLast(root);
        queueValue.addLast((Integer) root.getElement());

        while (!queueNode.isEmpty()){
            TreeNodeDefined node = queueNode.pollFirst();
            int value = queueValue.pollFirst();

            if (node.getLeftTree() == null && node.getRightTree() == null){
                if (value == targetSum){
                    return true;
                }
            }

            if (node.getLeftTree() != null){
                queueNode.addLast(node.getLeftTree());
                queueValue.addLast((Integer) node.getLeftTree().getElement() + value);
            }

            if (node.getRightTree() != null){
                queueNode.addLast(node.getRightTree());
                queueValue.addLast((Integer) node.getRightTree().getElement() + value);
            }
        }

        return false;
    }
```



##### [路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)

给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。

叶子节点 是指没有子节点的节点。

 <img src="https://gitee.com/zhanghui2233/image-storage-warehouse/raw/master/img//pathsumii1.jpg" alt="img" style="zoom:50%;" /> 

输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出：[[5,4,11,2],[5,8,4,5]]

```java
   /**
     * 给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。
     *
     * 叶子节点 是指没有子节点的节点。
     *
     输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
     输出：[[5,4,11,2],[5,8,4,5]]
     * @param root
     * @param targetSum
     * @return
     */
    private int pathValue = 0;
    private int target = 0;
    public List<List<Integer>> pathSum(TreeNodeDefined root, int targetSum) {
        //结果
        List<List<Integer>> res = new ArrayList<>();
        if (root == null){
            return res;
        }

        target = targetSum;

        //存放路径
        List<Integer> path = new ArrayList<>();
        traverse(root,res,path);
        return res;

    }

    private void traverse(TreeNodeDefined root, List<List<Integer>> res, List<Integer> path) {
        path.add((Integer) root.getElement());
        pathValue += (int)root.getElement();

        if (root.getLeftTree() == null && root.getRightTree() == null){
            if (pathValue == target){
                res.add(new ArrayList<>(path));
            }
        }

        if (root.getLeftTree() != null){
            traverse(root.getLeftTree(),res,path);
            //如果已经到达叶子节点那么要进行回溯
            pathValue -= path.get(path.size()-1);
            path.remove(path.size()-1);
        }

        if (root.getRightTree() != null){
            traverse(root.getRightTree(),res,path);
            //如果已经到达叶子节点那么要进行回溯
            pathValue -= path.get(path.size()-1);
            path.remove(path.size()-1);
        }
    }
```





##### [从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

根据一棵树的中序遍历与后序遍历构造二叉树。

注意:
你可以假设树中没有重复的元素。

例如，给出

中序遍历 inorder = [9,3,15,20,7]
后序遍历 postorder = [9,15,7,20,3]
返回如下的二叉树：

```
    3
   / \
  9  20
    /  \
   15   7
  
```

```java
  /**
     * 还原二叉树规则：
     *
     * 首先在后序遍历序列中找到根节点(最后一个元素)
     * 根据根节点在中序遍历序列中找到根节点的位置
     * 根据根节点的位置将中序遍历序列分为左子树和右子树
     * 根据根节点的位置确定左子树和右子树在中序数组和后续数组中的左右边界位置
     * 递归构造左子树和右子树
     * 返回根节点结束
     *
     * 根据一棵树的中序遍历与后序遍历构造二叉树。
     * 中序遍历 inorder = [9,3,15,20,7]
     * 后序遍历 postorder = [9,15,7,20,3]
     *
     *     3
     *    / \
     *   9  20
     *     /  \
     *    15   7
     *
     *    inorder:中序数组
     *    postorder：后续数组
     */
    //用来存放中序列数组,通过HashMap的key-value来快速找到根节所在的位置
    HashMap<Integer,Integer>  map =  new HashMap<>();
    //用来存放后续数组
    int[] post;
    public TreeNodeDefined buildTree(int[] inorder, int[] postorder) {
        //将中序数组按顺序放入Map集合中
        for (int i = 0; i < inorder.length; i++) {
            map.put(inorder[i],i);
        }
        //将后序数组放入post中
        post = postorder;

        TreeNodeDefined root = traverse(0 ,inorder.length -1 ,0,postorder.length-1);

        return root;

    }


    /**
     * 找到后序数组最后一位作为根节点，分割中序数组和后续数组
     * @param ms 分割后的中序数组的左子树的起始位置
     * @param me 分割后的中序数组的右子树的最终位置
     * @param es 分割后的后序数组的左子树的起始位置
     * @param ee 分割后的后序数组的右子树的最终位置
     *           分割后的中序数组的左子树的长度和分割后的后序数组的左子树长度一致
     *           分割后的中序数组的右子树的长度和分割后的后序数组的右子树长度一致
     * @return
     */
    private TreeNodeDefined traverse(int ms, int me, int es, int ee) {
        //数组大小为0，代表空节点
        if (me < ms || ee < es){
            return null;
        }

        //找到后序数组的最后一位,也就是根节点
        int root = post[post.length-1];
        //根据根节点找到它在中序数组上的位置
        int p =map.get(root);

        //根据p所在的位置开始划分中序数组和后序数组各自的左子树和右子树的范围
        TreeNodeDefined node = new TreeNodeDefined(root);
        //中序数组左子树范围，后序数组左子树范围（ee:后续数组的起始位置加上左子树长度-1 就是后后序数组结束位置了）
        node.setLeftTree(traverse(ms,p-1,es,es+p-ms-1));
        //中序数组右子树范围，后序数组右子树范围
        node.setRightTree(traverse(p+1,me,es+p-ms,ee-1));
        return node;

    }
```





##### [从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

给定一棵树的前序遍历 `preorder` 与中序遍历 `inorder`。请构造二叉树并返回其根节点。

<img src="https://gitee.com/zhanghui2233/image-storage-warehouse/raw/master/img//tree.jpg" alt="img" style="zoom:80%;" />

```
Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
Output: [3,9,20,null,null,15,7]
```

```java
  /**
     * 根据一棵树的前序遍历与中序遍历构造二叉树。
     *
     * 注意:
     * 你可以假设树中没有重复的元素。
     *
     * 例如，给出
     *
     * 前序遍历 preorder = [3,9,20,15,7]
     * 中序遍历 inorder = [9,3,15,20,7]
     *     3
     *    / \
     *   9  20
     *     /  \
     *    15   7
     *
     * 类似，从头开始查找
     * @param preorder 前序数组
     * @param inorder  中序数组
     * @return
     */
    //用来存放中序列数组,通过HashMap的key-value来快速找到根节所在的位置
    HashMap<Integer,Integer>  map1 =  new HashMap<>();
    //用来存放前序数组
    int[] post1;
    public TreeNodeDefined buildTree1(int[] preorder, int[] inorder) {
        //将中序数组按顺序放入Map集合中
        for (int i = 0; i < inorder.length; i++) {
            map1.put(inorder[i],i);
        }
        //将后序数组放入post中
        post1 = preorder;

        TreeNodeDefined root = traverse1(0 ,inorder.length -1 ,0,preorder.length-1);

        return root;

    }

    /**
     *
     * 找到前序数组第一位一位作为根节点，分割中序数组和前续数组
     * @param ms 分割后的中序数组的左子树的起始位置
     * @param me 分割后的中序数组的右子树的最终位置
     * @param ps 分割后的前序数组的左子树的起始位置
     * @param pe 分割后的前序数组的右子树的最终位置
     *           分割后的中序数组的左子树的长度和分割后的前序数组的左子树长度一致
     *           分割后的中序数组的右子树的长度和分割后的前序数组的右子树长度一致
     * @return
     */
    private TreeNodeDefined traverse1(int ms, int me, int ps, int pe) {
        //数组大小为0，代表空节点
        if (me < ms || pe < ps){
            return null;
        }

        //找到前序数组的最后一位,也就是根节点
        int root = post1[ps];
        //根据根节点找到它在中序数组上的位置
        int p =map1.get(root);

        //根据p所在的位置开始划分中序数组和前序数组各自的左子树和右子树的范围
        TreeNodeDefined node = new TreeNodeDefined(root);
        //中序数组左子树范围，前序数组左子树范围（pe:前序数组的起始位置加上左子树长度 就是前序数组结束位置了）
        node.setLeftTree(traverse1(ms,p-1,ps+1,ps+p-ms));
        //中序数组右子树范围，前序数组右子树范围
        node.setRightTree(traverse1(p+1,me,ps+p-ms+1,pe));
        return node;
    }

```





##### [最大二叉树](https://leetcode-cn.com/problems/maximum-binary-tree/)


给定一个不含重复元素的整数数组 `nums` 。一个以此数组直接递归构建的 **最大二叉树** 定义如下：

1. 二叉树的根是数组 `nums` 中的最大元素。
2. 左子树是通过数组中 **最大值左边部分** 递归构造出的最大二叉树。
3. 右子树是通过数组中 **最大值右边部分** 递归构造出的最大二叉树。

返回有给定数组 `nums` 构建的 **最大二叉树** 。

<img src="https://gitee.com/zhanghui2233/image-storage-warehouse/raw/master/img//tree1.jpg" alt="img" style="zoom:67%;" />

```
输入：nums = [3,2,1,6,0,5]
输出：[6,3,5,null,2,0,null,null,1]
解释：递归调用如下所示：
- [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。
    - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。
        - 空数组，无子节点。
        - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。
            - 空数组，无子节点。
            - 只有一个元素，所以子节点是一个值为 1 的节点。
    - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。
        - 只有一个元素，所以子节点是一个值为 0 的节点。
        - 空数组，无子节点。
```

```java
   /**
     * 给定一个不含重复元素的整数数组 nums 。一个以此数组直接递归构建的 最大二叉树 定义如下：
     *
     * 二叉树的根是数组 nums 中的最大元素。
     * 左子树是通过数组中 最大值左边部分 递归构造出的最大二叉树。
     * 右子树是通过数组中 最大值右边部分 递归构造出的最大二叉树。
     * 返回有给定数组 nums 构建的 最大二叉树 。
     *
     输入：nums = [3,2,1,6,0,5]
     输出：[6,3,5,null,2,0,null,null,1]
     解释：递归调用如下所示：
     - [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。
     - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。
     - 空数组，无子节点。
     - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。
     - 空数组，无子节点。
     - 只有一个元素，所以子节点是一个值为 1 的节点。
     - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。
     - 只有一个元素，所以子节点是一个值为 0 的节点。
     - 空数组，无子节点。
     * @param nums
     * @return
     */
    public TreeNodeDefined constructMaximumBinaryTree(int[] nums) {
        return traverse2(nums,0,nums.length-1);
    }

    private TreeNodeDefined traverse2(int[] nums, int s, int e) {
        if (e < s ){
            return  null;
        }

        if(e  == s){
            return new TreeNodeDefined(nums[s]);
        }


        int maxValue = Integer.MIN_VALUE;
        int p = 0;
        for (int j = s; j <=e ; j++) {
            if (nums[j] > maxValue){
                maxValue = nums[j];
                p = j;
            }
        }

        TreeNodeDefined root = new TreeNodeDefined(maxValue);
        root.setLeftTree(traverse2(nums,s,p-1));
        root.setLeftTree(traverse2(nums,p+1,e));
        return root;
    }
```



##### [合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/)

给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。

你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。

```java
输入: 
	Tree 1                     Tree 2                  
          1                         2                             
         / \                       / \                            
        3   2                     1   3                        
       /                           \   \                      
      5                             4   7                  
输出: 
合并后的树:
	     3
	    / \
	   4   5
	  / \   \ 
	 5   4   7
```

```java
  /**
     * 给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。
     * <p>
     * 你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。
     * <p>
     * 输入:
     * Tree 1                     Tree 2
     * 1                         2
     * / \                       / \
     * 3   2                     1   3
     * /                           \   \
     * 5                             4   7
     * 输出:
     * 合并后的树:
     * 3
     * / \
     * 4   5
     * / \   \
     * 5   4   7
     * 注意: 合并必须从两个树的根节点开始。
     * 递归
     *
     * @param root1
     * @param root2
     * @return
     */
    public TreeNodeDefined<Integer> mergeTrees(TreeNodeDefined<Integer> root1, TreeNodeDefined<Integer> root2) {

        if (root2 == null) {
            return root1;
        }
        if (root1 == null) {
            return root2;
        }
        TreeNodeDefined<Integer> root = new TreeNodeDefined(root1.getElement() + root2.getElement());

        root.setLeftTree(mergeTrees(root1.getLeftTree(), root2.getLeftTree()));
        root.setRightTree(mergeTrees(root1.getRightTree(), root2.getRightTree()));

        return root;

    }

    /**
     * 迭代法
     * 在root1的基础上，把root2上的节点加到root1中，因为通过迭代法前序遍历，无法创建新的二叉树
     * @param root1
     * @param root2
     * @return
     */
    public TreeNodeDefined<Integer> mergeTrees1(TreeNodeDefined<Integer> root1, TreeNodeDefined<Integer> root2) {


        //建立一个栈，分别存放root1，root2
        Deque<TreeNodeDefined<Integer>> stack1 = new LinkedList<>();
        stack1.push(root1);
        stack1.push(root2);

        while (!stack1.isEmpty()){
            //root2中的节点
            TreeNodeDefined<Integer> node1 = stack1.pop();
            //root1中的节点
            TreeNodeDefined<Integer> node2 = stack1.pop();
            node2.setElement(node2.getElement()+node1.getElement());

            if (node2.getRightTree() != null && node1.getRightTree() != null ){
                stack1.push(node2.getRightTree());
                stack1.push(node1.getRightTree());
            }else{
                //如果root1的右子树为空，就将root2中的右子树赋给root1的右子树。
                if (node2.getRightTree() == null){
                    node2.setRightTree(node1.getRightTree());
                }
            }

            if (node2.getLeftTree() != null && node1.getLeftTree() != null ){
                stack1.push(node2.getLeftTree());
                stack1.push(node1.getLeftTree());
            }else{
                //如果root1的左子树为空，就将root2中的左子树赋给root1的右子树。
                if (node2.getLeftTree() == null){
                    node2.setLeftTree(node1.getLeftTree());
                }
            }


        }
        return root1;

    }
```



##### [二叉搜索树中的搜索](https://leetcode-cn.com/problems/search-in-a-binary-search-tree/)

给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。

```
给定二叉搜索树:

        4
       / \
      2   7
     / \
    1   3

和值: 2

返回
      2     
     / \   
    1   3
```

```java
   /**
     * 给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。
     * 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。
     *
     * 给定二叉搜索树:
     *
     *         4
     *        / \
     *       2   7
     *      / \
     *     1   3
     *
     * 和值: 2
     *
     *       2
     *      / \
     *     1   3
     *
     * 递归
     * @param root
     * @param val
     * @return
     */
    public TreeNodeDefined<Integer> searchBST(TreeNodeDefined<Integer> root, int val) {

        //不存在符号的话
        if(root == null){
            return null;
        }

        //在二叉树中找到了与和值相等的节点
        if (root.getElement() == val ){
            return root;
        }


        //二叉搜索树特点
        if (val < root.getElement()){
            //小于当前根节点
           return searchBST(root.getLeftTree(),val);
        }else{
            //大于当前根节点
           return searchBST(root.getRightTree(),val);
        }

    }

    /**
     * 迭代法
     * @param root
     * @param val
     * @return
     */
    public TreeNodeDefined<Integer> searchBST1(TreeNodeDefined<Integer> root, int val) {
//        Deque<TreeNodeDefined<Integer>> stack = new LinkedList<>();
//        stack.push(root);
//        TreeNodeDefined<Integer> res = null;
//
//        while (!stack.isEmpty()){
//            TreeNodeDefined<Integer> node = stack.pop();
//            if (node.getElement() == val ){
//                 res = node;
//                 break;
//            }
//            if (val < node.getElement()  && node.getLeftTree() != null){
//                stack.push(node.getLeftTree());
//            }
//            if (val > node.getElement() && node.getRightTree() != null){
//                stack.push(node.getRightTree());
//            }
//        }
//
//        return res;

        while (root != null){
            if (root.getElement() > val){
                root =root.getLeftTree();
            }else  if (root.getElement() < val){
                root =root.getRightTree();
            }else {
                return root;
            }
        }
        return root;
    }
```



##### [验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

给定一个二叉树，判断其是否是一个有效的二叉搜索树。

假设一个二叉搜索树具有如下特征：

节点的左子树只包含小于当前节点的数。
节点的右子树只包含大于当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。

```
输入:
    5
   / \
  1   4
     / \
    3   6
输出: false
解释: 输入为: [5,1,4,null,null,3,6]。
     根节点的值为 5 ，但是其右子节点值为 4 。

```

```java
/**
     * 给定一个二叉树，判断其是否是一个有效的二叉搜索树。
     *
     * 假设一个二叉搜索树具有如下特征：
     *
     * 节点的左子树只包含小于当前节点的数。
     * 节点的右子树只包含大于当前节点的数。
     * 所有左子树和右子树自身必须也是二叉搜索树。
     * 输入:
     *     5
     *    / \
     *   1   4
     *      / \
     *     3   6
     * 输出: false
     * 解释: 输入为: [5,1,4,null,null,3,6]。
     *      根节点的值为 5 ，但是其右子节点值为 4 。
     *输入:
     *     2
     *    / \
     *   1   3
     * 输出: true
     *
     * 递归
     * 一开始想用前序遍历，想着只要满足判断左子树小于根节点，右子树大于根节点，进行递归，目光不够全面。
     * 例如：
     *     10
     *   3    18
     *      6    20
     * 这个就不是一个二叉搜索树，6这个节点就不符合，要求时以10为根节点，要求10左边的子树都要小于10，10右边的子树都要大于10.
     *
     *后面想想通过中序遍历，会让题目变得很顺手。
     * 中序遍历顺序：左中右
     * 从一个二叉树最底层最左边开始作比较，如果这个树是一个二叉搜索树，那么会发现这是一个递增的过程。
     * 注意：空二叉树也是一个二叉搜索树
     * @param root
     * @return
     */
    long pre = Long.MIN_VALUE;
    public boolean isValidBST(TreeNodeDefined<Integer> root) {
        if (root == null){
            return true;
        }

        boolean left = isValidBST(root.getLeftTree());
        if (pre < root.getElement()){
            pre = root.getElement();
        }else{
            return false;
        }

        boolean right = isValidBST(root.getRightTree());

        return left && right;
    }


    /**
     * 迭代法
     * @param root
     * @return
     */
    long pre1 = Long.MIN_VALUE;
    public boolean isValidBST1(TreeNodeDefined<Integer> root) {
        if (root == null) {
            return true;
        }
        Deque<TreeNodeDefined<Integer>> stack = new LinkedList<>();

        while (root != null || !stack.isEmpty()){
            //最底部最左叶子节点放入完毕
            if (root != null){
                stack.push(root);
                root = root.getLeftTree();
            }else {
                //出栈
                TreeNodeDefined<Integer> node = stack.pop();
                if (pre1 < node.getElement()){
                    pre1 = node.getElement();
                }else {
                    return false;
                }

                root = node.getRightTree();
            }
        }

        return true;

    }
```



##### [二叉搜索树的最小绝对差](https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/)

给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。

```
输入：

   1
    \
     3
    /
   2

输出：
1

解释：
最小绝对差为 1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。

```

```java
 /**
     * 给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。
     * 输入：
     *
     *    1
     *     \
     *      3
     *     /
     *    2
     *
     * 输出：
     * 1
     *
     * 解释：
     * 最小绝对差为 1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。
     * 递归（采用中序遍历）
     * 二叉树被形象的排列成一个递增数组，求递增数组的差的绝对值的最小值
     * @param root
     * @return
     */
    public int res = Integer.MAX_VALUE;
    public TreeNodeDefined<Integer> pre2;
    public int getMinimumDifference(TreeNodeDefined<Integer> root) {
        if (root == null){
            return res;
        }

        getMinimumDifference(root.getLeftTree());
        if(pre2 != null){
            res = Math.min(res,root.getElement() - pre2.getElement());
        }
        pre2 = root;
        getMinimumDifference(root.getRightTree());

        return res;
    }

    /**
     * 迭代法
     * @param root
     * @return
     */
    public int getMinimumDifference1(TreeNodeDefined<Integer> root) {
        if (root == null){
            return res;
        }
        Deque<TreeNodeDefined<Integer>> stack = new LinkedList<>();

        while (root != null || !stack.isEmpty()){
            if (root != null){
                stack.push(root);
                root = root.getLeftTree();
            }else {
                TreeNodeDefined<Integer> node = stack.pop();
                if (pre2 != null){
                    res = Math.min(res,node.getElement() - pre2.getElement());
                }

                pre2 = node;


                root =node.getRightTree();

            }
        }
        return res;
    }
```





##### [二叉搜索树中的众数](https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/)


给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。

假定 BST 有如下定义：

- 结点左子树中所含结点的值小于等于当前结点的值
- 结点右子树中所含结点的值大于等于当前结点的值
- 左子树和右子树都是二叉搜索树

例如：
给定 BST `[1,null,2,2]`,

```
   1
    \
     2
    /
   2
```

`返回[2]`.

```java
  /**
     * 给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。
     *
     * 假定 BST 有如下定义：
     *
     * 结点左子树中所含结点的值小于等于当前结点的值
     * 结点右子树中所含结点的值大于等于当前结点的值
     * 左子树和右子树都是二叉搜索树
     * 例如：
     * 给定 BST [1,null,2,2],
     *   1
     *     \
     *      2
     *     /
     *    2
     *
     *
     * @param root
     * @return
     */
    //记录出现频率最高的数值

    List<Integer> list = new ArrayList<>();
    //记录最大频率
    int maxCount;
    //记录每个数出现的频率
    int count;
    //记录上一个节点
    TreeNodeDefined<Integer> pre3;
    public int[] findMode(TreeNodeDefined<Integer> root) {
        int[] res = new int[list.size()];
        for (int i = 0; i < list.size(); i++) {
            res[i] = list.get(i);
        }
        traverse(root);

        return res;
    }

    public void traverse(TreeNodeDefined<Integer> root){
        if (root == null){
            return ;
        }

        findMode(root.getLeftTree());
        //第一个数
        if (pre3 == null){
            count = 1;
        }else if (pre3.getElement().equals(root.getElement())){
            //数值相等
            count++;
        }else {
            //数值发生了改变,重新计数
            count =1 ;
        }

        pre3 = root;

        //每遍历一次节点，都要判定一下，每个数的频率
        //count 和 maxCount相等时
        if (count == maxCount){
            list.add(root.getElement());
        }

        //出现了新的数值的频率大于当前最大的频率
        if (count > maxCount){
            maxCount = count;
            list.clear();
            list.add(root.getElement());
        }


        findMode(root.getRightTree());
    }
```







##### [二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)


给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

![img](https://gitee.com/zhanghui2233/image-storage-warehouse/raw/master/img//binarytree.png)

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
```

```java
   /**
     * 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
     *
     * 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，
     * 满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
     *
     *
     * 输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
     * 输出：5
     * 解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
     *
     * 首先p、q两个目标节点存在与二叉树中，需要先找到这个两个目标所在的位置，然后返回它们，作比较。
     * 根据这样的规律，能看出这是从二叉树的底部开始往上遍历的过程非常适合(后续遍历)，
     * 整个过程是一个回溯的过程，必然要遍历整个二叉树
     *
     *找到最近公共组先的条件就是：p、q分别是该公共节点的（左/右子树）或（右/左子树）
     * 这是一个最理想的状态目标，也是需要去实现到达的状态的目标。
     * 例如：
     *            2
     *       4         5
     *    6     8     9    1
     *        0   7
     * 1.找出 0 ，7 的最近公共组先，0，7是目标节点，通过后续遍历到0，7时，返回他们，和8这个节点，作比较，满足最近公共祖先的条件，返回节点8，
     * 后续继续遍历其他节点，最后回到根节点2，此时它的左节点为8，右节点为null，最后返回节点8.
     *
     * 2.找出6，7的最近公共组先，从目标节点6开始，返回6，来到8这个节点下，0不是目标节点，7是目标节点，因此对于8节点，它的左节点为null,
     * 右节点为7，返回右节点7，在来到四这个节点，它的左节点是4，右节点是7，满足条件，因此4是最近公共祖先，后续继续遍历其他节点，最后回到根节点2，
     * 此时它的左节点为4，右节点为null，最后返回节点4
     *
     * 3.找出4，6的最近公共组先，从目标节点6开始，返回6， 来到8之后的节点，不存在目标节点因此都是返回null，到了4这个节点，
     * 发现它本身就是目标节点，返回4，同时另一个目标节点在它左子树中，因此4本身成了最近公共祖先。
     *
     * 还有其他的情况和2、3左右树的位置相反。
     *
     * 总结一下成为最近公共组先的条件。
     * 1.root = null (叶子节点) return null
     * 2.root = p 或 q  return  root(p/q)
     * 3.left（左子树）!= null && right（右子树） ！= null, return root(最近公共组先)
     *   p =root ，且  q 在 root 的左或右子树中；
     *  q =root ，且 p 在 root 的左或右子树中；
     *
     * 4.left == null && right != null return right;
     * 5.left != null && right == null return left;
     *
     *
     * @param p
     * @param q
     * @return
     */
    public TreeNodeDefined lowestCommonAncestor(TreeNodeDefined root, TreeNodeDefined p, TreeNodeDefined q) {
        //节点是目标节点p、q或者当前节点为null时
        if (root == p || root == q || root == null){
            return root;
        }


        TreeNodeDefined left = lowestCommonAncestor(root.getLeftTree(),p,q);
        TreeNodeDefined right = lowestCommonAncestor(root.getRightTree(),p,q);

        //当前节点为最近公共祖先
        if (left != null && right != null){
            return root;
        }
        //左边为目标节点，右边为空节点
        if (left != null){
            return left;
        }
        //右边为目标节点，左边为空节点
        return right;


    }
```







### 回溯算法

回溯算法又叫**回溯搜索法**，也是一种搜索算法。



**回溯和递归的关系**

递归中包含着回溯的过程，递归本身就是深度优先搜索的一种典型方法，在二叉树算法中，递归可以解决二叉树中全部的问题，这其中都包含着回溯，只不过有些递归中并没有显示的用到回溯，有些问题中还是需要显示地运用回溯来解决问题。比如：**求二叉树中从根节点到各个叶子节的路径**[二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)



**回溯算法的效率**

回溯本身就是一种穷举方法，通过列出所有方法，选择我们需要的，因此回溯的效率并不高，之所以采用它是因为对于有些问题能够通过穷举法推出结果就已经是用尽全力了，没有更高效的方法。



**回溯算法解决的典型问题**

- 组合问题
- 切割问题
- 子集问题
- 排列问题
- 棋盘问题

<img src="https://camo.githubusercontent.com/3bcac8ab20d3edb4151fb58a0b7c09bcf33b70bfd4a422bd74215429dd697fd6/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303231393139323035303636362e706e67" alt="回溯算法大纲" style="zoom: 50%;" />

这里提一下**组合和排列**

看字知其意，组合并**不强调顺序**，比如：水果的组合，跟种类有关，跟顺序无关。排列**强调顺序**，比如：[1、2]和[2、1]就是两种不同的排列。



**回溯算法的模板**

- 确定回溯算法的名命以及参数
- 回溯算法的终止条件
- 回溯算法的遍历过程

一般名命用**backtracking**，参数一般是在**实现逻辑之后需要什么参数就放入什么参数**。

伪代码

```java
void backtracking(参数)
```



终止条件

**回溯法解决的问题都可以抽象为树形结构**，因此需要确定终止条件，一般来说递归到叶子节点，也就找到了满足条件的一条答案，需要结束本层递归。

伪代码

```java
if (终止条件) {
    存放结果;
    return;
}
```



遍历过程

<img src="https://gitee.com/zhanghui2233/image-storage-warehouse/raw/master/img//image-20210718211039361.png" alt="image-20210718211039361" style="zoom: 67%;" />

图中：设定叶子节点是各个解合的子集，各个集合的长度和叶子节点相等。

通过for循环横向遍历，**集合的长度决定for循环遍历的次数**。(和层序遍历有点像)

在for循环体中执行递归函数，当递归函数完成本层递归通过终止条件return，回溯，这样一来就将整个n叉树遍历完成。

伪代码

```java
for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
    处理节点;
    backtracking(路径，选择列表); // 递归
    回溯，撤销处理结果
}
```



完整的伪代码

```java
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```



##### [组合](https://leetcode-cn.com/problems/combinations/)

给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。

你可以按 **任何顺序** 返回答案。

```
示例 1：

输入：n = 4, k = 2
输出：
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]

```

```java
   /**组合
     *
     * 给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。
     *
     * 你可以按 任何顺序 返回答案。
     *
     * 输入：n = 4, k = 2
     * 输出：
     * [
     *   [2,4],
     *   [3,4],
     *   [2,3],
     *   [1,2],
     *   [1,3],
     *   [1,4],
     * ]
     *
     * 将[1，n]看成一个数组，求数组中组合大小为k的数量，数组又可以看成是一个n叉树.
     *
     *
     * @param n
     * @param k
     * @param start
     * @return
     */
    //存放组合,相当于树的路径
    List<Integer> path = new ArrayList<>();
    //存放结果集
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> combine(int n, int k) {

        //start：表示开始位置，因为每个点遍历过后就不需要再次遍历了，防止重复
        traverse(n,k,1);
        return  res;
    }

    public void traverse(int n, int k, int start){
        //终止条件，当path中大小等于 k时
        if (path.size() == k){
            //当前path中的组合满足要求
            res.add(new ArrayList<>(path));
            return ;
        }

        //横向遍历，例如：[1,4],从1 开始横向遍历
        //for循环中 ，如果终止条件 i<= ?, 当中?这个值如果是n（整个数组长度），这样做并不好，因此它会将整个数组都遍历一边，
        //但是有些题目中不需要这么去做，比如 n = 4 ,k =3,在[1,4]中找到组合长度为3的组合，肉眼可见：123，124，134，234。
        //只有这四种，理想的遍历过程是遍历到start = 2 为止，后面不需要在遍历了，因为不存在符合的结果，因此需要将这些没有的遍历都做剪枝操作
        // 现在就将? 把原来的n 替换为到2位置。
        //k-path.size() :还需要长度。
        //n - (k-path.size()) + 1: 最多能够到达的位置，之后的位置都不成立。例如 path.size() =0 , 4-(3-0)+1 = 2,表示start = 2 就是极限的位置。
        for (int i = start; i <= n - (k-path.size()) + 1 ; i++) {
            //将每次遍历的数加入path中
            path.add(i);
            //从1节点开始往下递归，与1进行组合的种类
            traverse(n,k,i+1);
            //递归完后，返回，进行回溯，将满足的组合存放res中，将path中的结果回溯到1，1在于其他数进行组合
            path.remove(path.size()-1);
        }

    }
```



##### [组合总和 III](https://leetcode-cn.com/problems/combination-sum-iii/)

找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。

说明：

所有数字都是正整数。
解集不能包含重复的组合。

```
示例 1:

输入: k = 3, n = 7
输出: [[1,2,4]]
示例 2:

输入: k = 3, n = 9
输出: [[1,2,6], [1,3,5], [2,3,4]]
```

```java
    /**
     * 组合总和 III
     * 找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。
     *
     * 说明：
     *
     * 所有数字都是正整数。
     * 解集不能包含重复的组合。 
     *
     * 输入: k = 3, n = 7
     * 输出: [[1,2,4]]
     *
     * 输入: k = 3, n = 9
     * 输出: [[1,2,6], [1,3,5], [2,3,4]]
     * @param k
     * @param n
     * @return
     */
    //存放组合,相当于树的路径
    List<Integer> path1 = new ArrayList<>();
    //存放结果集
    List<List<Integer>> res1= new ArrayList<>();
    //和
    int all = 0;
    public List<List<Integer>> combinationSum3(int k, int n) {

        traverser1(k,n,1);
        return res1;
    }

    public void traverser1(int k, int n,int start){
        //剪枝操作
        // all > n时
        if (all > n) {
            return;
        }

        //终止条件,满足长度为k的组合并且和为 n
        if (path1.size() == k && all == n){
            res1.add(new ArrayList<>(path1));
            return;
        }


        //题目要求和为n,组合的范围是[1,9],
        //剪枝操作
        //除了考虑组合长度之外，还要考虑组成的数的和大于 n的情况。因为是递增的关系，所以大于 n 的组合以及其之后的组合都不成立
        for (int i = start; i <= 9 - (k-path1.size())+1; i++) {
            path1.add(i);
            all += i;
            //i+1,防止重复
            traverser1(k, n, i+1);
            //回溯
            //和回溯
            all -= path1.get(path1.size()-1);
            //节点回溯
            path1.remove(path1.size()-1);

        }
    }
```





##### [电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

<img src="https://gitee.com/zhanghui2233/image-storage-warehouse/raw/master/img//17_telephone_keypad.png" alt="img" style="zoom:50%;" />

```
示例 1：

输入：digits = "23"
输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
示例 2：

输入：digits = ""
输出：[]
```

```java
  /**
     *
     * 电话号码的字母组合
     给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。

     给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

     1.如何让数组对应字母
     2.组合问题可以用回溯，简单粗暴的for循环不可取
     3.输入1的异常情况
     * @param digits
     * @return
     */

    public  List<String> letterCombinations(String digits) {
        //将数字和字母对应起来
        Map<Character ,String> map = new HashMap<>();
        map.put('1',"");
        map.put('2',"abc");
        map.put('3',"def");
        map.put('4',"ghi");
        map.put('5',"jkl");
        map.put('6',"mno");
        map.put('7',"pqrs");
        map.put('8',"tuv");
        map.put('9',"wxyz");
        //结果集
        List<String> res = new ArrayList<>();

        if (digits.length() == 0){
            return res;
        }


        traverse2(digits,map,res,0);
        return res;

    }

//    //StringBuilder 来拼接字符
    StringBuilder stringBuilder = new StringBuilder();

    //index表示遍历到字符串digits第几个字符
    private  void traverse2(String digits, Map<Character, String> map, List<String> res,int index) {
        //返回的组合条件：组合的长度(组成的字符串长度) == digits.length
        if (stringBuilder.length() == digits.length()){
            res.add(String.valueOf(stringBuilder));
            return;
        }

        //取出字符在2-9之间
        String string = map.get(digits.charAt(index));
        //for循环的次数是和数组对应字符串长度挂钩的
        for (int i = 0; i < string.length(); i++) {
                stringBuilder.append(string.charAt(i));
                //index + 1 遍历下一个字符：比如:digits：23，下一个字符就是3
                traverse2(digits,map,res,index+1);
                //进行回溯
                stringBuilder.deleteCharAt(stringBuilder.length()-1);
        }

    }
```







##### [组合总和](https://leetcode-cn.com/problems/combination-sum/)

给定一个无重复元素的正整数数组 candidates 和一个正整数 target ，找出 candidates 中所有可以使数字和为目标数 target 的唯一组合。

candidates 中的数字可以无限制重复被选取。如果至少一个所选数字数量不同，则两种组合是唯一的。 

对于给定的输入，保证和为 target 的唯一组合数少于 150 个。

```
示例 1：

输入: candidates = [2,3,6,7], target = 7
输出: [[7],[2,2,3]]
示例 2：

输入: candidates = [2,3,5], target = 8
输出: [[2,2,2,2],[2,3,3],[3,5]]
示例 3：

输入: candidates = [2], target = 1
输出: []
示例 4：

输入: candidates = [1], target = 1
输出: [[1]]
```



```java
    /**
     *  组合总和
     * 给定一个无重复元素的正整数数组 candidates 和一个正整数 target ，找出 candidates 中所有可以使数字和为目标数 target 的唯一组合。
     *
     * candidates 中的数字可以无限制重复被选取。如果至少一个所选数字数量不同，则两种组合是唯一的。 
     *
     * 对于给定的输入，保证和为 target 的唯一组合数少于 150 个。
     *  输入: candidates = [2,3,6,7], target = 7
     * 输出: [[7],[2,2,3]]
     * @param candidates
     * @param target
     * @return
     */

    //结果集
    List<List<Integer>> res = new ArrayList<>();
    //路径
    List<Integer> path = new ArrayList<>();
    //组合的和
    int all = 0;
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        Arrays.sort(candidates);
        //注意start表示数组遍历的开始位置，因为组合中的数允许重复，因此递归时要加入本身
        traverser(candidates,target,0);
        return  res;

    }

    private void traverser(int[] candidates, int target, int start) {
//        //剪枝操作，组合的和大于 target已经超出范围
            // 优化：
        // 虽然做到了剪枝，但是仔细想一想其实判断到这一步对应递归的上一次结果其实就可以去判断all 是否 满足target
//        if (all > target){
//            return;
//        }

        //满足条件,终止条件1
        if (all == target){
            res.add(new ArrayList<>(path));
            return;
        }


        //注意将&& all + candidates[i] <= target放入for循环的中间时，并在把原来的集合进行升序排序之后，如果下一次all > target,就可以结束本次的循环
        for (int i = start; i  < candidates.length && all + candidates[i] <= target; i++) {
            //虽然可以把判断放在这里单还是进行了for循环内部，并没有实质上的大提升
//            if (all > target){
//                continue;
//            }
            path.add(candidates[i]);
            all += candidates[i];
            //这里start的值不再是start+1，start+1表示递归下一个值不包含本身，start被赋值为 for循环的i
            traverser(candidates,target,i);
            //回溯
            all -= candidates[path.size() - 1];
            path.remove(path.size() - 1);
        }



    }
```





##### [分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/)

给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是 **回文串** 。返回 `s` 所有可能的分割方案。

**回文串** 是正着读和反着读都一样的字符串。



**示例 1：**

```
输入：s = "aab"
输出：[["a","a","b"],["aa","b"]]
```

**示例 2：**

```
输入：s = "a"
输出：[["a"]]
```

```java
  /**
     * 分割回文串
     * 给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。
     *
     * 回文串 是正着读和反着读都一样的字符串。
     * 示例 1：
     *
     * 输入：s = "aab"
     * 输出：[["a","a","b"],["aa","b"]]
     *
     * 回文子串的思路和数组组合类似，它们相同之处在于，无重复元素的数组在筛选组合不允许再筛选本身（这里说的是题目中不允许选重复的元素），
     * 回文子串是不允许重复分割本身。
     * 例如 s = aab的分割过程。
     * 首先从a开始分割，起始位置：0，分割的位置也是0，分割后，判断是否是回文子串，是加入数组path2中，起始位置向后+1
     * 起始位置：1，分割也是1，分割的字符是a，判断是否是回文子串，是加入数组path2中，起始位置向后+1
     *  起始位置：2，分割也是2，分割的字符是b，判断是否是回文子串，是加入数组path2中，起始位置向后+1,
     *  终止条件：如果当前起始位置 >= 字符总长度，返回一个结果集给res。
     *  已经走到叶子节点了，注意要进行回溯，回到返回结果集的上一层，起始位置：2的结果集已经回溯，也就是起始位置为1，此时for循环结束一轮，
     *  i++，终止位置为2，分割的范围是[1,2],对应字符是:ab,不是回文子串，因此不需要往下递归了，直接跳出这次的循环，for循环结束后，
     *  递归结束回到上一进行回溯，此时path2中为空，起始位置为0，结束一次for循环，i++，此时i =1 ,分割的位置为[0,1]对应的字符串为：aa,
     *  判断是回文子串，加入path2，因此递归i+1,起始位置:2,分割的位置为[2,2]，对应字符串:b,是回文子串，加入path2,递归i+1,
     *  满足终止条件加入集合res2，返回，进行回溯，for循环结束，回到上一层，回溯到起始位置0，一层for循环结束，i++,i=2，分割位置[0,2]对应
     *  字符串为:aab，不符合，for循环结束，返回结果。
     *
     * @param s
     * @return
     */
    List<String> path2 = new ArrayList<>();
    List<List<String>> res2 = new ArrayList<>();
    public List<List<String>> partition(String s) {

        traverser2(s,0);
        return res2;

    }

    private void traverser2(String s, int start) {
        //终止条件，分割的位置 >= 字符串的长度时。表明到达尾部了
        if (start == s.length()){
            res2.add(new ArrayList<String>(path2));
            return;
        }


        for (int i = start; i < s.length() ; i++) {
            //判断切割的是否是回文子串
            if (isPalindromeString(s,start,i)){
                path2.add(s.substring(start,i+1));
            }else {
                //剪枝操作，不是回文字符
                continue;
            }
            traverser2(s,i+1);
            //回溯
            path2.remove(path2.size()-1);
        }
    }

    private boolean isPalindromeString(String s, int start, int i) {
        for (int j = start  , k = i; j < k ; j++,k-- ) {
            if (s.charAt(j) != s.charAt(k)){
                return false;
            }
        }

        return true;

    }
```





##### [复原 IP 地址](https://leetcode-cn.com/problems/restore-ip-addresses/)


给定一个只包含数字的字符串，用以表示一个 IP 地址，返回所有可能从 `s` 获得的 **有效 IP 地址** 。你可以按任何顺序返回答案。

**有效 IP 地址** 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 `0`），整数之间用 `'.'` 分隔。

例如："0.1.2.201" 和 "192.168.1.1" 是 **有效** IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 **无效** IP 地址。

```
示例 1：

输入：s = "25525511135"
输出：["255.255.11.135","255.255.111.35"]
示例 2：

输入：s = "0000"
输出：["0.0.0.0"]
示例 3：

输入：s = "1111"
输出：["1.1.1.1"]
```



```java
  /**
     *复原 IP 地址
     给定一个只包含数字的字符串，用以表示一个 IP 地址，返回所有可能从 s 获得的 有效 IP 地址 。你可以按任何顺序返回答案。

     有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。

     例如："0.1.2.201" 和 "192.168.1.1" 是 有效 IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 无效 IP 地址。
     示例 1：

     输入：s = "25525511135"
     输出：["255.255.11.135","255.255.111.35"]
     * @param s
     * @return
     */
    List<String> resStr = new ArrayList<>();
    public List<String> restoreIpAddresses(String s) {
        //每个整数位于 0 到 255 之间组成,四个整数
        if (s.length() > 12){
            return resStr;
        }
        traverser3(s,0,0);
        return resStr;

    }

    private void traverser3(String s, int start,  int periodNums) {
        //终止条件,只要进行了第四次的分割就要结束后面的判断，periodNums == 3 时，判断是否符合有效Ip
        if (periodNums == 3){
            if (isEffectiveIP(s,start,s.length()-1)){
                resStr.add(s);
            }
            return ;
        }


        for (int i = start; i <s.length() ; i++) {
            //判断分割后的整数是否符合有效ip
            if (isEffectiveIP(s,start,i)){
                //在s字符串上更改，好处是方便回溯的时候能够找到对应的位置，之前使用了StringBuilder来拼接发现回溯的过程位置定位不准确
                //导致问题出现
                s = s.substring(0,i+1)+"."+s.substring(i+1);
                periodNums++;
                //因为在s字符串的基础上加了.分割符号，因此往后多位移一位，才是一下次要分割的位置
                traverser3(s,i+2,periodNums);
                //回溯
                periodNums--;
                //将分隔符去除。
                s = s.substring(0,i+1)+s.substring(i+2);
            }else {
                break;
            }
        }
    }


    private boolean isEffectiveIP(String s, int start, int end) {
        if (start > end){
            return false;
        }

        int value = 0;
        //非法字符和不能大于255
        for (int i = start; i <= end ; i++) {
            if (s.charAt(i) > '9' || s.charAt(i) < '0'){
                return false;
            }

            //将字符类型转换成int类型，比如315对应十进制315，
            // 取第一个3 ， 0 * 10 + 3 = 3
            //取第二个1 ，十进制表示31， 3 * 10 + 1 = 31
            //取第三个5 ，十进制表示315， 31 * 10 + 5 = 315
            value = value * 10 + (s.charAt(i) - '0');
            if (value > 255){
                return false;
            }

        }

//        不能含有前导 0,组成ip的整数端中长度超过1位时，不能以0开头
        if ('0' == s.charAt(start) && start != end){
            return false;
        }
        //每个整数位于 0 到 255 之间组成


        return true;
    }
```





##### [子集](https://leetcode-cn.com/problems/subsets/)

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。

```
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```



```java
 /**
     * 子集
     * 给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。
     *
     * 解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。
     * 输入：nums = [1,2,3]
     * 输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
     * @param nums
     * @return
     */
    List<Integer> sList = new ArrayList<>();
    List<List<Integer>> res3 = new ArrayList<>();
    public List<List<Integer>> subsets(int[] nums) {
        //空集是任何集合的子集
        res3.add(sList);
        if (nums.length == 0){
            return res3;
        }
        traverser4(nums,0);
        return res3;

    }

    private void traverser4(int[] nums, int start) {
//        终止条件每次遍历将组成的最后一个子集加入
        if (start == nums.length){
            return;
        }

        for (int j = start; j < nums.length ; j++) {
            sList.add(nums[j]);
            res3.add(new ArrayList<>(sList));
            //不允许重复,j+1
            traverser4(nums,j+1);
            //回溯
            sList.remove(sList.size()-1);
        }

    }
```



##### [子集 II](https://leetcode-cn.com/problems/subsets-ii/)

给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。

解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。

```
示例 1：

输入：nums = [1,2,2]
输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]

输入：nums = [0]
输出：[[],[0]]
```

```java

    /**
     * 子集 II
     * 给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。
     *
     * 解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。
     *输入：nums = [1,2,2]
     * 输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]
     * @param nums
     * @return
     */
    List<Integer> sList = new ArrayList<>();
    List<List<Integer>> res3 = new ArrayList<>();
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        //升序排序
        Arrays.sort(nums);
        //空集是任何集合的子集
        res3.add(sList);
        if (nums.length == 0){
            return res3;
        }
        //去重，设定一个状态数据,默认为0
        int[] flag = new int[nums.length];
        traverser5(nums,0,flag);
        return res3;
    }

    private void traverser5(int[] nums, int start,int[] flag) {
//        终止条件,每次遍历将组成的最后一个子集加入
        if (start == nums.length){
            return;
        }

        for (int j = start; j < nums.length ; j++) {
            //重复判断，如果遍历过的数字就设定为1，
            if (j > 0 && nums[j] == nums[j-1] && flag[j-1] == 0 ){
                continue;
            }
            flag[j] = 1;
            sList.add(nums[j]);
            res3.add(new ArrayList<>(sList));
            //不允许重复,j+1
            traverser5(nums,j+1, flag);
            //回溯
            flag[j] = 0;
            sList.remove(sList.size()-1);
        }

    }
```





##### [递增子序列](https://leetcode-cn.com/problems/increasing-subsequences/)

给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是 2 。	

```
示例：

输入：[4, 6, 7, 7]
输出：[[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]

```

```java
    /**
     * 递增子序列
     *
     * 给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是 2 。
     *
     * 输入：[4, 6, 7, 7]
     * 输出：[[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]
     *
     * 这道题目其实是前面求子集问题的一个延申，子集Ⅱ问题中的问题涉及到去重问题，当然这里也有，区别在于这里的数组是无序的。
     * 在这里不能使用子集问题的去重逻辑，因为数组无序的原因导致重复数字并不在一起，自己中的数组按照升序排列的，因此可以使用。
     * 这里改用set集合中hashset来解决去重问题，hashset记录当前遍历层中已经使用过的数字，回溯的过程如果发现当前层中数字已经使用过了，那么跳过，
     *还有一个问题就是如果当前数字与paths中记录的上一个数字相比，当前数字小，那么不满足递增条件，因此也要跳过。
     * @param nums
     * @return
     */
    List<Integer> paths = new ArrayList<>();
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> findSubsequences(int[] nums) {
        traverser(nums,0);
        return res;
    }

    private void traverser(int[] nums, int start) {
        //题目要求：找出的递增子序列的长度至少大于等于2
        if(paths.size() >= 2){
            //放入集合中
            res.add(new ArrayList<>(paths));
        }


        //注意：这里的去重不再是之前子集中的去重，这个数组是乱序，相同的数并不连在一起，可能是分散开的
        Map<Integer,Integer> usedNums = new HashMap<>();
        for (int i = start; i < nums.length ; i++) {
            if ((!paths.isEmpty() && nums[i] < paths.get(paths.size() -1 ))
                    || usedNums.containsKey(nums[i])){
                continue;
            }

            usedNums.put(nums[i],i);
            paths.add(nums[i]);
            //递归往下找下一个，
            traverser(nums,i+1);
            //回溯
            paths.remove(paths.size() -1 );

        }

    }
```





##### [全排列](https://leetcode-cn.com/problems/permutations/)

给定一个不含重复数字的数组 `nums` ，返回其 **所有可能的全排列** 。你可以 **按任意顺序** 返回答案。

 

```
示例 1：

输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

```java
 /**
     * 全排列
     * 给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。
     *
     * 输入：nums = [1,2,3]
     * 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
     *
     * 和之前的组合、分割、子集相比，排序问题在于[1,2]和[2,1]各是一种答案，因此要考虑到选择过的数字可能需要再次作为下一次排序中的
     * 一种可能性。
     * 不再是用start标记下一位的选择位置，而是使用一个数组来判断，当前排序中改数字有没有被选中过，选中过那么跳过
     * @param nums
     * @return
     */
    List<List<Integer>> res1 = new ArrayList<>();
    List<Integer> paths1 = new ArrayList<>();
    public List<List<Integer>> permute(int[] nums) {

        //排列问题要区分数组中哪些数字被选择过,默认为0
        int[] flag = new int[nums.length];
        traverser1(nums , flag);
        return  res1;
    }

    private void traverser1(int[] nums, int[] flag) {
        //终止条件:全排列要求和nums长度一致的组合，不仅仅式组合问题，而是要考虑到顺序问题，排序问题
        if (paths1.size() == nums.length){
            res1.add(new ArrayList<>(paths1));
            return;
        }

        for (int i = 0; i < nums.length ; i++) {
            //当前数字被选择过，跳过
            if (flag[i] == 1){
                continue;
            }
            //选择过的数字设置为 1
            flag[i] = 1;
            paths1.add(nums[i]);
            //排列问题需要从头开始
            traverser1(nums, flag);
            //回溯
            flag[i] = 0;
            paths1.remove(paths1.size() - 1);
        }

    }
```



##### [全排列 II](https://leetcode-cn.com/problems/permutations-ii/)

给定一个可包含重复数字的序列 `nums` ，**按任意顺序** 返回所有不重复的全排列。

```
示例 1：

输入：nums = [1,1,2]
输出：
[[1,1,2],
 [1,2,1],
 [2,1,1]]
示例 2：

输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

```java
    /**
     * 全排列 II
     * 给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。
     *
     * 输入：nums = [1,2,3]
     * 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
     *
     * 输入：nums = [1,1,2]
     * 输出：
     * [[1,1,2],
     *  [1,2,1],
     *  [2,1,1]]
     * @param nums
     * @return
     */
List<List<Integer>> res1 = new ArrayList<>();
    List<Integer> paths1 = new ArrayList<>();
    public List<List<Integer>> permute(int[] nums) {

        //排列问题要区分数组中哪些数字被选择过,默认为0
        int[] flag = new int[nums.length];
        traverser1(nums , flag);
        return  res1;
    }

    private void traverser1(int[] nums, int[] flag) {
        //终止条件:全排列要求和nums长度一致的组合，不仅仅式组合问题，而是要考虑到顺序问题，排序问题
        if (paths1.size() == nums.length){
            res1.add(new ArrayList<>(paths1));
            return;
        }

        Map<Integer,Integer> usedNums = new HashMap<>();
        for (int i = 0; i < nums.length ; i++) {
            //当前数字被选择过，跳过
            //这不是一个升序数组，因此不能使用升序数组中的去重逻辑，而是要用hashset集合来完成
            if (flag[i] == 1 || (usedNums.containsKey(nums[i]))){
                continue;
            }
            //选择过的数字设置为 1
            flag[i] = 1;
            usedNums.put(nums[i],i);
            paths1.add(nums[i]);
            //排列问题需要从头开始
            traverser1(nums, flag);
            //回溯
            flag[i] = 0;
            paths1.remove(paths1.size() - 1);
        }

    }
```





##### [重新安排行程](https://leetcode-cn.com/problems/reconstruct-itinerary/)

给你一份航线列表 tickets ，其中 tickets[i] = [fromi, toi] 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。

所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。

例如，行程 ["JFK", "LGA"] 与 ["JFK", "LGB"] 相比就更小，排序更靠前。
假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。

![img](https://assets.leetcode.com/uploads/2021/03/14/itinerary1-graph.jpg)

```
输入：tickets = [["MUC","LHR"],["JFK","MUC"],["SFO","SJC"],["LHR","SFO"]]
输出：["JFK","MUC","LHR","SFO","SJC"]
```

```java
  /**
     * 重新安排行程
     * 给你一份航线列表 tickets ，其中 tickets[i] = [fromi, toi] 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。
     *
     * 所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。
     *
     * 例如，行程 ["JFK", "LGA"] 与 ["JFK", "LGB"] 相比就更小，排序更靠前。
     * 假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。
     *
     * 输入：tickets = [["MUC","LHR"],["JFK","MUC"],["SFO","SJC"],["LHR","SFO"]]
     * 输出：["JFK","MUC","LHR","SFO","SJC"]
     *
     * @param tickets
     * @return
     */
    //ticketsMap用来记录出发机场到降落机场的对应关系,
    //第一个String表示出发机场
    //第二个String表示降落机场
    //使用TreeMap来存储是因为降落机场的顺序需要按照字典顺序来排序
    //Integer用来记录达到过的标志,防止重复,默认为大于0表示没有达到过,小于0表示为已经到达过
    public static   Map<String , Map<String ,Integer>> ticketsMap = new HashMap<>();

    public static List<String> findItinerary(List<List<String>> tickets) {
        Deque<String> res = new LinkedList<>();


        //将tickets中初始化到ticketsMap中
        for (List<String> ticket: tickets) {
            Map<String,Integer>  tmp ;
            //获取降落机场和到达次数的对应关系
            //若ticketsMap存在多张出发机场到降落机场的机票
            //Map 的containsKey () 方法来检测数据 (value)是否存在,
            // 如果key存在, 则表明已经获取过一次数据, 那么直接返回该 key 在 Map 中的值.
            if (ticketsMap.containsKey(ticket.get(0))){
                //存在,获取降落机场和状态的映射关系
                // Map.get() 方法返回指定键所映射的值
                tmp = ticketsMap.get(ticket.get(0));
                //Map.getOrDefault(Object key, V defaultValue)方法的作用是：
                //  当Map集合中有这个key时，就使用这个key值；
                //  如果没有就使用默认值defaultValue。
                //这个方法判断的主要功能是若出现两张一模一样的机票,那么它们对应的Integer需要在原来第一张票的integer基础上+1
                //而不是在新建一张机票,会出现问题,例如:<JFK,<"JSF",2>>表示两张票.
                tmp.put(ticket.get(1),tmp.getOrDefault(ticket.get(1),0)+1);
            }else{
                //不存在,使用TreeMap排序:默认升序
                tmp = new TreeMap<>();
                //获取到达机场,并将其状态设置为1
                tmp.put(ticket.get(1),1);

            }

            ticketsMap.put(ticket.get(0),tmp);
        }

        //题目规定从JFK机场出发
        res.add("JFK");

        travers(res,tickets.size());

        return  new ArrayList<>(res);
    }

    /**
     *
     * @param res 返回结果集
     * @param nums 终止条件
     */
    private static boolean travers(Deque<String> res, int nums) {
        //终止条件.当票数+1和记录结果集相同时,表明所用的机票都是用过了,并且这是叶子节点
        //例如:手里有三张机票,最后的到达地点是4个.
        if(res.size() == nums +1){
            return true;
        }

        //取出res中最后一位在ticketsMap中寻找对用的机票
        String last = res.getLast();
        if (ticketsMap.containsKey(last)){
            for (Map.Entry<String, Integer> ticket : ticketsMap.get(last).entrySet()) {
                int flag = ticket.getValue();
                //这里要查看对应降落的机场是否已经达到过,去重
                if ( flag  > 0){
                    //没有到达过
                    res.add(ticket.getKey());
                    //更新机票状态
                    ticket.setValue(flag - 1);
                    //递归
                    //只要找到了所有的结果集在那么在终止条件返回true,直接返回结果
                    if (travers(res,nums)){
                        return true;
                    }
                    //回溯
                    res.pollLast();
                    ticket.setValue(flag);
                }
            }
        }
        return  false;
    }
```



##### [N 皇后](https://leetcode-cn.com/problems/n-queens/)

n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。

每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。

<img src="https://gitee.com/zhanghui2233/image-storage-warehouse/raw/master/img//image-20210815171739940.png" alt="image-20210815171739940" style="zoom:67%;" />

```
输入：n = 4
输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
解释：如上图所示，4 皇后问题存在两个不同的解法。
```

```java
/**
 * n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。
 *
 * 给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。
 *
 * 每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。
 *
 * 输入：n = 4
 * 输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
 * @param n
 * @return
 */
List<List<String>> res = new ArrayList<>();
public List<List<String>> solveNQueens(int n) {
    //n x n的二维数组
    char[][]  sortPaths = new char[n][n];
    //初始化["....","....","....","...."]
    for (char[] c : sortPaths) {
        Arrays.fill(c,'.');
    }

    travers1(n,0,sortPaths);
    return  res;


}

/**
 *  @param n  n x n矩阵的长度(列数)
 * @param row 代表行数
 * @param sortPaths
 */
private void travers1(int n, int row, char[][] sortPaths) {
    //终止条件:当递归到最后一行对应叶子节点时，也就是排列完成的时候
    if (row == n){
        //这里要将二维数据进行处理
        List<String> tmp = new ArrayList<>();
        for (char[] c: sortPaths) {
            tmp.add(String.valueOf(c));
        }
        res.add(tmp);
        return;
    }

    //for循环代表每一行选择的方法数量
    for (int i = 0; i < n ; i++) {
        //判断当前皇后的位置是否符合
        if (isVaildQueen(row,i,n,sortPaths)){
            //符合加入
            sortPaths[row][i] = 'Q';
            //递归下一层，row+1因为是深层递归，因此不存在有皇后在同一行的情况，在判断皇后中就没有进行同行判断了
            travers1(n,row+1,sortPaths);
            //回溯
            sortPaths[row][i]= '.';
        }
        //不符合跳过
    }


}

/**
 * 皇后当前的位置
 * 判断是否符合
 * 不在同一行、同一列同、同一对角线、(在这些范围内有没有其他皇后)
 *
 * @param row 行
 * @param i 列
 * @param n nxn的举证
 * @param sortPaths
 * @return
 */
private boolean isVaildQueen(int row, int i, int n, char[][] sortPaths) {
    //同一列
    //这里j < row ,如果当前皇后不是最后一行，那么只需要看当前皇后row行上的同一列是否有皇后就可以了
    for (int j = 0; j < row; j++) {
        //同列中出现Q
        if (sortPaths[j][i] == 'Q'){
            return false;
        }
    }

    //同一对角线
    //左对角线,在当前皇后点以上的左对角线，从后往前，最后对应矩阵中的左边界(不一定是00，根据皇后的位置来确定)
    // row:行  i:代表列
    for (int j = row - 1 , k = i - 1; j >=0 && k >= 0 ; j--,k--) {
        if (sortPaths[j][k] == 'Q'){
            return false;
        }
    }

    //右对角线
    //在当前皇后点以上的右对角线，从前往后，最后对应矩阵中的右边界
    for (int j = row - 1 , k = i+1 ; j >=0 && k < n ; j--,k++) {
        if (sortPaths[j][k] == 'Q'){
            return false;
        }
    }

    return true;
}
```



### 贪心算法

本质：通过局部上的最优解能够得到全局的最优解。

举例：从一堆钞票中拿钞票，要求拿十次最后得到的数目最大，只要每次拿最大面值的钞票就可以了，这就是局部最优解，十次最优解加起来就可以称为全局最优解。

贪心算法步骤：

1. 将全局问题分解成若干个子问题
2. 选择合适的贪心策略
3. 求出每个子问题的最优解
4. 将每个子问题的最优解放在一起 称为全局问题的最优解



##### [分发饼干](https://leetcode-cn.com/problems/assign-cookies/)

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。



```java
    /**
     * 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。
     *
     * 对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。
     *
     * 输入: g = [1,2,3], s = [1,1]
     * 输出: 1
     * 解释:
     * 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
     * 虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
     * 所以你应该输出1。
     *
     * 题目要求用饼干尽可能满足孩子的胃口，贪心策略就是尽可能满足胃口大的孩子，饼干越大对应胃口越大的孩子局部最优
     * @param g
     * @param s
     * @return
     */
    public int findContentChildren(int[] g, int[] s) {
        //排序升序
        Arrays.sort(g);
        Arrays.sort(s);

        //双指针，从后开始，对应孩子
        int child = g.length-1;
        int biscuit = s.length-1;
        int nums = 0;

       while (biscuit >= 0 && child >= 0){
           if (s[biscuit] >= g[child]){
               //能够喂饱孩子
               nums++;
               biscuit--;
           }
           child--;
       }
        return nums;

    }
```



##### [摆动序列](https://leetcode-cn.com/problems/wiggle-subsequence/)

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。

例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。

相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。
子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。

给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。

```
示例 1：

输入：nums = [1,7,4,9,2,5]
输出：6
解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。
示例 2：

输入：nums = [1,17,5,10,13,15,10,5,16,8]
输出：7
解释：这个序列包含几个长度为 7 摆动序列。
其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。
示例 3：

输入：nums = [1,2,3,4,5,6,7,8,9]
输出：2

```

```java
  /**
     * 摆动序列
     * 如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。
     *
     * 例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。
     *
     * 相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。
     * 子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。
     *
     * 给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。
     *
     输入：nums = [1,7,4,9,2,5]
     输出：6
     解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。

     要保证数组是一个摆动序列，连续数字之间的差严格按照正数或负数交替，可以对原数组进行修改，让子序列称为满足条件的摆动序列
     题目要求返回摆动序列的长度。
     贪心：如果连续的数字之间的差值都是一个峰值(正数或负数)，保证每两个数字之间和它们上一个差值相是相反(正数或负数),整体上这个连续的数组就构成摆动序列
     若碰到单调性的连续序列，没法称为摆动数组，因此需要跳过，
     * @param nums
     * @return
     */
    public int wiggleMaxLength(int[] nums) {
        //记录连续摆动差值的数目
        int num = 0;

        //记录上一次的值，用来判断当前能否构成一个摇摆序列
        int preDiffer = 0;

        //当前差值
        int curDiffer = 0 ;

        for (int i = 1; i < nums.length ; i++) {
            curDiffer =nums[i] - nums[i-1];
            //满足条件
            if ((curDiffer > 0 &&  preDiffer <= 0) || (curDiffer < 0 && preDiffer >= 0)){
                num++;
                //记录当前的差值，用于下一次比较，不满足的不记录，只要知道符合条件的
                preDiffer = curDiffer;
            }
        }

        //[2,4,2]这是一个最长摆动序列,通过上述记录满足差值成立的数目是2，题目要求返回的是数组长度，因此+1.
        return num+1;
    }
```



##### [最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

```
示例 1：

输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
示例 2：

输入：nums = [1]
输出：1
示例 3：

输入：nums = [0]
输出：0
示例 4：

输入：nums = [-1]
输出：-1

```

```java
/**
     * 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
     *
     * 输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
     * 输出：6
     * 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
     *
     * 贪心：
     * 局部最优:保证这连续的数组不要是连续的负数，并且和不能为负数，若出现和小于0，任务这之前的连续数组无法拥有最大和，
     * 跳到下一个重新组合。
     * 全局最优：局部最优保证全局最优
     * @param nums
     * @return
     */
    public int maxSubArray(int[] nums) {
        //当数组中只有一位时
        if (nums.length == 1){
            return nums[0];
        }

        int maxValue = Integer.MIN_VALUE;

        int count = 0;

        for (int i = 0; i <nums.length ; i++) {
            count +=nums[i];
            //记录这次最大的值
            if (count > maxValue){
                maxValue = count;
            }
            //不合格
            if (count <= 0 ){
                count = 0;
            }


        }

        return maxValue;

    }
```



##### [买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

```
示例 1:

输入: prices = [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
示例 2:

输入: prices = [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。

```

```java
    /**
     *买卖股票的最佳时机 II
     给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。

     设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

     注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

     输入: prices = [7,1,5,3,6,4]
     输出: 7
     解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
          随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。

     贪心：买卖股票先买在卖必然的规定，也就是至少要两天的时间才能够有利润出现，并且每天可以卖出在买入。
     比如：[1, 5,4,6] 买入：b[0] 卖出:b[3].利润：b[3] - b[0] = 6-1 = 5
     等价于: 每两天之间产生利润之和  : 6 = (5 - 1) + (4 - 5)+(6 -4)=4+(-1)+2=5;
     如果将利润看在一个范围内的话，想要找出最大利润比较困难，其实还是通过将每天的利润列举出来，然后选择利润都为正的购买日期。
     满足了局部的最优，加起来就能够得出最大利润
     * @param prices
     * @return
     */
    public int maxProfit(int[] prices) {
        //记录最大利润
        int res = 0 ;
        //记录当前买卖产生的利润
        int cur  = 0;

        //若第一天买入，第二天才会产生利润，因此i从1开始
        for (int i = 1; i <prices.length ; i++) {
            cur = prices[i] - prices[i-1];
//            产生了正的利润
            if (cur > 0){
                res += cur;
            }
        }

        return res;
    }
```





给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标。



##### [跳跃游戏](https://leetcode-cn.com/problems/jump-game/)

给定一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标。

```
示例 1：

输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
示例 2：

输入：nums = [3,2,1,0,4]
输出：false
解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。

```

```java
 /**
     * 跳跃游戏
     * 给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。
     *
     * 数组中的每个元素代表你在该位置可以跳跃的最大长度。
     *
     * 判断你是否能够到达最后一个下标。
     *
     * 输入：nums = [2,3,1,1,4]
     * 输出：true
     * 解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
     *
     * 输入：nums = [3,2,1,0,4]
     * 输出：false
     * 解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。
     *
     * 贪心思想：题目说明数组中每个位置能够达到的最大范围，每移动一次就去把范围更新，相当于每次找最大的范围，看看更新后的范围是不是
     * 比原来大或者能够达甚至超过最后一个下标
     *
     * @param nums
     * @return
     */
    public boolean canJump(int[] nums) {
        if (nums.length == 1){
            return true;
        }

        //如何更新每次移动能够跳跃的范围呢？
        //数组索引对应数字代表能够跳跃的范围
        //取数组第一个下标对应的值，它表示i所能移动的范围，例如:[0,2,3],这个就不能够移动
        int scope = nums[0];

        //再范围内移动，找到能够扩大范围或者达到下标的值
        for (int i = 0; i <= scope ; i++) {

            //表示每次取值的最大范围
            //nums[i]+i表示计算当前数能够移动的范围
            scope = Math.max(nums[i]+i,scope);

            //能够到达最后一个下标
            if (scope >= nums.length -1 ){
                return true;
            }

        }

        return false;

    }

```



##### [跳跃游戏 II](https://leetcode-cn.com/problems/jump-game-ii/)

给你一个非负整数数组 nums ，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

你的目标是使用最少的跳跃次数到达数组的最后一个位置。

假设你总是可以到达数组的最后一个位置。

 

```
输入: nums = [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
示例 2:

输入: nums = [2,3,0,1,4]
输出: 2
```

```java
/**
     * 跳跃游戏 II
     * 给你一个非负整数数组 nums ，你最初位于数组的第一个位置。
     *
     * 数组中的每个元素代表你在该位置可以跳跃的最大长度。
     *
     * 你的目标是使用最少的跳跃次数到达数组的最后一个位置。
     *
     * 假设你总是可以到达数组的最后一个位置。
     *
     * 输入: nums = [2,3,1,1,4]
     * 输出: 2
     * 解释: 跳到最后一个位置的最小跳跃数是 2。
     *      从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
     *
     *
     *这个问题和上一个问题相比，难在这道题目是要记录跳跃的次数，关键在于如何去判断跳跃次数什么时候加一？
     * 上一个问题只需要判断是否能够到达最右侧下标，只需要不断更新范围，这个问题不只是更新范围，在第一次拿到的范围内的跳跃
     * 只要不超出这个范围，怎么跳都只算作一次跳跃，若达到当前范围的最大边界时，并且更新的范围中已经有能够达到最右侧下标，那
     * 跳跃次数就不用加一，反之需要加1
     *
     * @param nums
     * @return
     */
    public int jump(int[] nums) {
        if (nums.length == 1){
            return 0;
        }

        //记录跳跃次数
        int count = 0;

        //[1,2,3]
        //记录当前最大的范围,当前指：比如从初始下标1开始，能够跳跃的范围就是对应数组下标为1的位置
        //在这个范围内怎么跳越都是算作一次跳跃
        int currDis = 0;

        //下一次范围
        int nextDis = 0;

        for (int i = 0; i < nums.length ; i++) {

            //更新下一次的范围
            nextDis = Math.max(nextDis,nums[i]+i);

            //更新后的范围若能够达到最右侧下标
            if (nextDis > nums.length -1){
                //当前任然需要+1，因为还没有移动到以下为
                count++;
                break;
            }

            //i == 当前范围的最大边界,这一步的判断就是到了最大边界但是没有可以到达最右侧下标的点
            if (i == currDis){
                count++;
                currDis = nextDis;
            }



//            //只要跳跃的范围不超过上一次的范围，整个跳跃的过程只算一次跳跃
//            //如果当前的位置为currDis的最大值，并且这个位置上对应的范围没有办法到达最右侧的下标，只能够把跳跃次数加1
//            if (currDis == i ){
//                if (currDis < nums.length -1){
//                    count++;
//                    currDis = nextDis;
//                }
//                //这里是为了判断若在当前范围内存在可以达到最右侧下标就返回，非常典型[2,3,1,1,4]
//                //在i =2 时，在更新的过程中其实nextDis = 4 已经满足了要求
//                if (nextDis >= nums.length -1){
//                    break;
//                }
//
//            }

        }
        return count;
    }
```





##### [加油站](https://leetcode-cn.com/problems/gas-station/)

在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。

你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。

如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。

说明: 

如果题目有解，该答案即为唯一答案。
输入数组均为非空数组，且长度相同。
输入数组中的元素均为非负数。

```
示例 1:

输入: 
gas  = [1,2,3,4,5]
cost = [3,4,5,1,2]

输出: 3

解释:
从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
因此，3 可为起始索引。
```



```java
/**
 *
 * 加油站
 * 在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。
 *
 * 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。
 *
 * 如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。
 *
 * 说明: 
 *
 * 如果题目有解，该答案即为唯一答案。
 * 输入数组均为非空数组，且长度相同。
 * 输入数组中的元素均为非负数。
 *
 * 输入:
 * gas  = [1,2,3,4,5]
 * cost = [3,4,5,1,2]
 *
 *
 * 输出: 3
 *
 * 解释:
 * 从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
 * 开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
 * 开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
 * 开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
 * 开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
 * 开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
 * 因此，3 可为起始索引。
 *
 * 若从4号加油站开始,可以获得5升汽油 ,此时有5升汽油
 * 4 - 0  此时汽油 5 -2 +1 = 4
 * 0 - 1  此时汽油 4-3+2 = 3
 * 1 - 2  此时汽油 3+3 -4 = 2
 * 2 -3  2+3-4 = 1
 * 3 -4   2 - 5 = -3 不成立
 *
 */
public class second {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        //如果能够保证跑完一圈,那么油量的总和 大于等于 消耗的总和
        //用来记录当前加油站和消耗油量对应的差值之和
        int curSum = 0;
        //用来记录总和
        int totalSum = 0 ;
        int loc = 0;

        for (int i = 0; i < gas.length ; i++) {
            curSum += gas[i] - cost[i];
            totalSum += gas[i] - cost[i];
            //当前位置curSum < 0 该地不适合作为出发点
            if (curSum < 0){
                loc = i +1;
                curSum = 0;
            }
        }

        //无法跑完一圈
        if (totalSum < 0){
            return -1;
        }

        return loc;

    }
```





##### [分发糖果](https://leetcode-cn.com/problems/candy/)

老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。

你需要按照以下要求，帮助老师给这些孩子分发糖果：

每个孩子至少分配到 1 个糖果。
评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。
那么这样下来，老师至少需要准备多少颗糖果呢？

 

```java
示例 1：

输入：[1,0,2]
输出：5
解释：你可以分别给这三个孩子分发 2、1、2 颗糖果。
示例 2：

输入：[1,2,2]
输出：4
解释：你可以分别给这三个孩子分发 1、2、1 颗糖果。
     第三个孩子只得到 1 颗糖果，这已满足上述两个条件。

```

```java
 /**
     *
     * 分发糖果
     * 老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。
     *
     * 你需要按照以下要求，帮助老师给这些孩子分发糖果：
     *
     * 每个孩子至少分配到 1 个糖果。
     * 评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。
     * 那么这样下来，老师至少需要准备多少颗糖果呢？
     * 输入：[1,0,2]
     * 输出：5
     * 解释：你可以分别给这三个孩子分发 2、1、2 颗糖果。
     *
     * 按照要求，每个孩子至少能获得一块糖，在这个基础上
     * 保证分数高的孩子要比分数低的孩子的糖果数多，从单个孩子来看，分数高的孩子可能位于左侧，也可能位于右侧。
     *
     * 贪心方法分配糖果就是：
     * 先给所有的孩子都分配一颗糖。
     * 接下来规定：
     * 1：当前孩子A分数 > 上一位孩子B的分数 ： B A，当前孩子的糖果数是：NB+1,从左往右将数组遍历一边，找出所有的情况
     * 2: 当前孩子A分数  < 下一位孩子C的分数  ：C A,当前孩子的糖果数不变，C的糖果书 NA+1，从右往左将数组遍历一边，找出所有的情况
     * 最后取这里面的最值
     * @param ratings
     * @return
     */
    public int candy(int[] ratings) {

        //用来记录从左往右的糖果数
        int[] left = new int[ratings.length];
        //用来记录从右往左的糖果数
        int[] right = new int[ratings.length];
        //给所有孩子发一颗糖
        Arrays.fill(left,1);
        Arrays.fill(right,1);
        int max = 0;

        //从左往右开始
        for (int i = 1; i < ratings.length ; i++) {
            if (ratings[i-1] < ratings[i]){
                left[i] = left[i-1] + 1;
            }
        }

        //从右往左开始
        for (int i = ratings.length-2; i >= 0 ; i--) {
            if (ratings[i] > ratings[i+1]){
                right[i] = right[i+1] +1;
            }
            max += Math.max(left[i+1] ,right[i+1]);
        }

        return max;

    }
```



##### [柠檬水找零](https://leetcode-cn.com/problems/lemonade-change/)

在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。

每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。

注意，一开始你手头没有任何零钱。

给你一个整数数组 bills ，其中 bills[i] 是第 i 位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。

```
输入：bills = [5,5,10,10,20]
输出：false
解释：
前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。
对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。
对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。
由于不是每位顾客都得到了正确的找零，所以答案是 false。

```

```java
    public static boolean lemonadeChange(int[] bills) {
//        Map<Integer,Integer> map = new HashMap<>();
//        map.put(5,0);
//        map.put(10,0);
//        map.put(20,0);
        int five = 0 ;
        int ten = 0;
        int twen = 0;


        for (int i = 0; i < bills.length; i++) {
            //表示客人付款5元，无需找零
            if (bills[i] == 5){
                //5元数量加1
//                map.put(5,map.get(5)+1);
                five ++;
            }

            //表示客人付款10元，找零5元
            if (bills[i] == 10){
//                int fiveNumber = map.get(5);
//                if (fiveNumber - 1 < 0){
//                    return false;
//                }
//                //5元数量 -1
//                map.put(5,map.get(5)-1);
//                //10元数量加1
//                map.put(10,map.get(10)+1);
                if (five > 0){
                    five--;
                    ten++;
                }else {
                    return false;
                }
            }

            //表示客人付款20元，找零15元
            if (bills[i] == 20){
                if (five >0 && ten > 0){
                    five--;
                    ten--;
                }else if (five >= 3){
                    five -=3;
                }else {
                    return false;
                }
//                int fiveNumber = map.get(5);
//                int tenNumber = map.get(10);
//
//                //贪心：有10元先用10元找零
//                if (fiveNumber  > 0 && tenNumber > 0) {
//                    //5元数量 -1
//                    map.put(5,map.get(5)-1);
//                    //10元数量-1
//                    map.put(10,map.get(10)-1);
//                }else if (fiveNumber >= 3){
//                    //5元数量 -1
//                    map.put(5,map.get(5)-3);
//                }else {
//                    return false;
//                }
//
//
//
//                //20元数量加1
//                map.put(20,map.get(20)+1);
            }

        }

        return true;
    }

```





##### [根据身高重建队列](https://leetcode-cn.com/problems/queue-reconstruction-by-height/)

假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。

请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。

```
示例 1：

输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
解释：
编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。
编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。
编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。
编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。
编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。

```

```java
    /**
     * 根据身高重建队列
     * 假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。
     *
     * 请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。
     *
     * 输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
     * 输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
     * 解释：
     * 编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。
     * 编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。
     * 编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。
     * 编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
     * 编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。
     * 编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
     * 因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。
     *
     *
     * 这道题目和之前做到分发糖果很相似，都有两个条件需要考虑
     *
     * 思路：先从一个条件出发，得出符合题目要求的规律后，再从另一个方面出发
     * 此题有两个条件：1、H:人的身高 2、K:比当前人高的数目
     *
     * 此题从身高出发比较好，若从K开始进行排序，从大到小排序发现整个队列是混乱的，而从身高开始从大到小可以保证身高的顺序是确定的。
     * 多个条件肯定是要从有规律的一方开始着手，也不要两个一起考虑会把问题复杂化
     *
     * 身高排列好，按照：身高高的开始，根据k来重新组合顺序，最后使得身高和K符合所在的位置
     */
    public static int[][] reconstructQueue(int[][] people) {
        //身高排序：从大到小,身高相同k小的位于前面
        Arrays.sort(people, (Comparator<int[]>) (o1, o2) -> {
            if (o1[0] == o2[0]){
                return   o1[1] - o2[1];
            }else {
               return o2[0] - o1[0];
            }
        });

        //按照身高高的K开始,根据k的位置添加到对应的数组中，这里使用链表进行添加
        List<int[]> lists = new LinkedList<>();
        for (int[] list: people) {
            lists.add(list[1],list);
        }

        return lists.toArray(new int[lists.size()][]);
    }
```



##### [用最少数量的箭引爆气球](https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/)

在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。

一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。

给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。

```
示例 1：

输入：points = [[10,16],[2,8],[1,6],[7,12]]
输出：2
解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球
```

```java
 /**
     * 用最少数量的箭引爆气球
     * 在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。
     *
     * 一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。
     *
     * 给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。
     *
     *
     * 示例 1：
     *
     * 输入：points = [[10,16],[2,8],[1,6],[7,12]]
     * 输出：2
     * 解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球
     *
     *
     * 思路:最少的箭,射爆更多的气球(贪心)
     *
     * 每个气球都有边界,这里按照左边界开始排序,从小到大,遇到相同左边界的,按照右边界小的在前.
     * 根据气球的右边界来判断,若当前气球的左边界大于上一个气球的右边界说明当前的箭射不到当前所在气球的为止,需要加一个箭
     * 从第一个气球开始配置一个箭,每次遍历时将右边界更新数值,以更小的边界为主.可以自己画一画就知道为什么要更新更小的边界值
     * {{9,12},{1,10},{4,11},{8,12},{3,9},{6,9},{6,7}};
     * @param points
     * @return
     */
    public static int findMinArrowShots(int[][] points) {
        if (points.length == 0){
            return 0;
        }
        //排序
        Arrays.sort(points,(Comparator<int[]>) (o1, o2) ->{
            if (o1[0] == o2[0]){
                return   o1[1] - o2[1];
            }else if ( o1[0] > o2[0]){
                return 1;
            }else {
                return  -1;
            }
        });



        int arrow = 1;

        //从第一只气球开始配一只箭
        for (int i = 1; i < points.length ; i++) {
            //从第一只气球的右边界开始,发现有没有在这个边界范围内的气球,若有归属统一只箭:被射爆
            if (points[i][0] > points[i-1][1]){
                //超出弓箭的范围了
                arrow++;
            }else{
                //没有超出范围,把当前points[i][1]的值更新,选择更小的范围,因为当中排序后的气球可能会出现内嵌的情况(范围小的)
                //根据范围小的来决定
                points[i][1] = Math.min(points[i][1],points[i-1][1]);
            }
        }

        return arrow;
    }
```







##### [无重叠区间](https://leetcode-cn.com/problems/non-overlapping-intervals/)给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。

注意:

可以认为区间的终点总是大于它的起点。
区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。

```
输入: [ [1,2], [2,3], [3,4], [1,3] ]

输出: 1

解释: 移除 [1,3] 后，剩下的区间没有重叠。
```

```java
 /**
     * 无重叠区间
     * 给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。
     *
     * 注意:
     *
     * 可以认为区间的终点总是大于它的起点。
     * 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。
     *
     *
     * 这道题目把重复的区域删除,记录删除次数
     * 我是按照右边界来排序,从小到大,右边界越大表明可能产生重复区域的可能性越大
     *
     * 设立一个左边界left标识,右边界right标识,若有存在于当前范围内的区间说明有重叠需要删除,
     * @param intervals
     * @return
     */
    public static int eraseOverlapIntervals(int[][] intervals) {
        //排序
        // 照右边界来排序,从小到大
        Arrays.sort(intervals,(Comparator<int[]>) (o1,o2) ->{
            if (o1[1] > o2[1]){
                return 1;
            }else if (o1[1] < o2[1]){
                return -1;
            }else {
                return  0;
            }
        });


        int count = 0;
        //左边界标识
        int left = intervals[0][0] ;
        //右边界标识
        int right = intervals[0][1] ;

        for (int i = 1; i < intervals.length ; i++) {
            //存在重叠
            if (intervals[i][0] < right ){
                //删除计数
                count++;
                //跳出本次循环
                continue;
            }
            //取更小的边界
            left =Math.min(left,intervals[i][0]);
            //更新右边界范围
            right =Math.max(right,intervals[i][1]);
        }


        return  count;
    }
```

