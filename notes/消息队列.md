# 消息队列

## 概述

消息队列(MQ) Message Queue 是分布式系统中重要的中间件，在很多生产环境中比如商品抢购，秒杀等需要控制并发量的场景下使用。

典型场景：**当短时间内访问量突然激增，是平常访问量的几十倍甚至上百倍，服务器在短时间内肯定没有办法一次性处理这么多的数据，就可以将未处理的请求放入通过消息队列中进行缓存，减少服务器的压力**



一般常用的消息队列组件为：**RabbitMQ、RocketMQ、ActiveMQ、Kafka等**，部分数据库例如Redis、Mysql也可以是实现消息队列的功能。



## 应用场景

消息队列主要解决的问题：**应用耦合、异步处理、流量削峰、消息通讯**



- **异步处理： 多个应用对于同一消息进行处理，应用间通过并发处理，相比串行处理，消耗的时间要少**

  场景应用：**用户注册**

  用户注册流程：用户注册、新用户信息填写、发送注册邮件、发送注册信息

  1. 通过串行方法进行处理

     <img src="https://picturebedzhanghui.oss-cn-hangzhou.aliyuncs.com/img/image-20211010102255275.png" alt="image-20211010102255275" style="zoom:80%;" />

     假设不考虑网络延迟，每个过程都需要10s，整个过程从注册发送小心再到返回消息所耗费的时间就是40s

     

  2. 通过并行方法进行处理

     <img src="https://picturebedzhanghui.oss-cn-hangzhou.aliyuncs.com/img/image-20211010102511084.png" alt="image-20211010102511084" style="zoom: 67%;" />

     将发送邮件和发送信息并行处理，这里相比于串行处理，所耗费的时间相对减少。整个过程花费30s时间

     

  3. 使用消息队列

     <img src="https://picturebedzhanghui.oss-cn-hangzhou.aliyuncs.com/img/image-20211010102824514.png" alt="image-20211010102824514" style="zoom:67%;" />

     这里使用消息队列来进行处理，在注册信息写入后，将其加入到消息队列中，因为是异步直接就会将结果返回给客户端。相比于上面其他的过程，它们是同步的一个过程，需要等待服务端返回结果。使用消息队列的优势就在于此，则总的响应时间依赖于写入消息队列的时间，而写入消息队列的时间本身是可以很快的，基本可以忽略不计整个过程也就是花费了20s，速度是串行处理的两倍，是并行处理的1倍。

- **应用耦合： 多应用间通过消息队列对同一消息进行处理，避免调用接口失败导致整个过程失败**

  多个应用：可能是多个类之间、多个方法之间、多个系统之间。

  降低它们之间的耦合度，避免因耦合度过高，出现小错误而导致整个系统的全部崩溃。

  场景应用：**图片上传进行人脸识别**

  启动流程：通过图片上传系统进行图片上传，上传完的图片调用人脸识别系统进行识别。

  <img src="https://picturebedzhanghui.oss-cn-hangzhou.aliyuncs.com/img/image-20211010132332571.png" alt="image-20211010132332571" style="zoom:80%;" />

  该调用方法存在缺点：

  1. 图片上传系统 **直接调用** 人脸识别系统，它们之间的耦合性很高，当人脸识别系统出现了错误就会导致图片上传出现问题。
  2. 延迟高，因为两个系统直接耦合，当图片上传完成后，需要等待人脸识别系统处理完成后，才能返回。

  

  

  采用消息队列让两个系统之间进行 **解耦合**

  <img src="https://picturebedzhanghui.oss-cn-hangzhou.aliyuncs.com/img/image-20211010132726325.png" alt="image-20211010132726325" style="zoom:67%;" />

  1. 图片上传系统将图片上传后，写入到消息队列中，直接返回图片上传成功信息
  2. 人脸识别系统从消息队列中拿图片进行处理，完成人脸识别的功能。

  这样做好处：

  - 图片上传系统 和人脸识别系统之间没有直接的关联性，它们都是通过消息队列来完成业务，因此当其中一个系统出了问题并不会直接影响另一个系统。
  - 图片上传系统不需要关心人脸识别系统如何返回处理结果，它只需要完成图片上传工作即可，而人脸识别系统通过消息队列来完成人脸识别任务。解耦合。

- **限流消锋：广泛应用于秒杀或抢购活动中，避免因流量过大导致应用系统挂掉的情况**

  场景应用：**购物秒杀活动，短时间内访问量激增，远远超过服务器能够处理的数量，此时就需要使用消息队列来中缓冲**

  <img src="https://picturebedzhanghui.oss-cn-hangzhou.aliyuncs.com/img/image-20211010134819236.png" alt="image-20211010134819236" style="zoom: 80%;" />

  通过使用消息队列，将大量的请求先放入当中，服务器按照自己的节奏来处理消息队列中的请求，一定程度上减少了服务器的压力。

  可以设置消息队列长度，例如秒杀商品，可以根据商品的数量来设置消息队列长度，先进入消息队列用户可以被服务器所处理，当商品被抢完，对应消息队列已满，对于后序请求可以直接拒绝。

- **消息驱动：系统分为消息队列、消息生产者、消息消费者，生产者负责产生消息，消费者(可能有多个)负责对消息进行处理**

  应用场景：**图片上传+人脸识别+对账系统**

  通过图片上传功能进行图片上传，人脸识别系统需要对这个用户的所有照片进行聚类，聚类完成后由对账系统重新生成用户的人脸索引(加快查询)。

  采用消息队列

  ![image-20211010135953592](https://picturebedzhanghui.oss-cn-hangzhou.aliyuncs.com/img/image-20211010135953592.png)

  在图片上传、人脸识别系统之间， 图片上传系统是**消息生产者**、人脸识别系统是**消息消费者**。在人脸识别、对账系统之间，人脸识别是**消息生产者**、对账系统是**消息消费者**。

  这样的好处

  - 三个系统之间通过消息队列进行业务处理，解耦合。
  - 每个系统对于生产的消息处理更加的灵活，可以选择收到消息时就处理，可以选择定时处理，也可以划分时间段按不同处理速度处理



## 模型

消息队列中有两种模型：**队列模型(点对点模型)**和 **发布/订阅模型**



### 队列模型（点对点）

生产者、消息队列、消费者

<img src="https://picturebedzhanghui.oss-cn-hangzhou.aliyuncs.com/img/image-20211010141338768.png" alt="image-20211010141338768" style="zoom: 80%;" />

生产者生产消息放入到消息队列中，消息队列中可以存放多个生产者生产的消息， 队列中有多个消费者，但是每个消息只能被一个消费者消费，因此多个消费者之间存在竞争关系，被消费的消息不会存在于队列中。



该模型的优点：

1. 生产者和消费者之间不存在直接的联系，因此双方互不影响，通过消息队列在完成业务。解耦合
2. 被消费者消费的消息会被移出消息队列中。



### 发布/订阅模型

生产者、订阅、消费者



上面提到的 队列模型，一个消息只能被一个消费者所消费。**现在需要保证一个消息能被多个消费者消费，就出现了发布/订阅模型**。

<img src="https://picturebedzhanghui.oss-cn-hangzhou.aliyuncs.com/img/image-20211010143251055.png" alt="image-20211010143251055" style="zoom:80%;" />

生产者生产的消息，放入到**Topic(主题)**中，**所有订阅该Topic的消费者都可以消费这条消息**。

举一个生活中的例子：QQ群中有很多网友，其中一个网友发送一条消息到群里，其他人都可以看到这条消息，这就是一种典型的发布/订阅模型。

若给你的朋友单独发送一条消息，只有你的朋友能接收，其他人是无法接收的，这就是队列模型。

**那么队列模型能不能实现一条消息给多个消费者消费呢？**

**答案是可以的，实现多个队列模型将同一条消息发送给多个消费者，这样在多队列模型情况下也能够实现发布/订阅模型效果**

`RabbitMQ` 采用队列模型，`RocketMQ`和`Kafka` 采用发布/订阅模型。



**接下来都是以 发布/订阅模型为基础的内容**

生产者称为：**Producer**，消费者称为：**Consumer**，消息队列称为：**Broker**。

消息从**Producer**发往**Broker**，**Broker**将消息存储至本地，然后**Consumer**从**Broker**拉取消息，或者**Broker**推送消息至**Consumer**，最后消费。

<img src="https://picturebedzhanghui.oss-cn-hangzhou.aliyuncs.com/img/image-20211010144315730.png" alt="image-20211010144315730" style="zoom: 80%;" />

为了提高**并发度**，在发布/订阅模型中Topic中区域中加入了**队列或分区**，**这里队列和分区是同一个，只是叫法不同，在不同的消息队列中`RocketMQ`中叫队列，`Kafka`叫分区，本质一样。**

<img src="https://picturebedzhanghui.oss-cn-hangzhou.aliyuncs.com/img/image-20211010145314162.png" alt="image-20211010145314162" style="zoom:80%;" />

在Topic中加入两个队列，这个主题的并发度就是2，同时可以有两个消费者**并行消费该主题的消息**

一般通过轮询将同一个主题的消息分配到不同队列中。



每个消费者都有它们对应的消费组 **Consumer Group**，一条消息会发往多个订阅了该主题的消费组。

假设现在有两个消费组分别是`Group 1` 和 `Group 2`，它们都订阅了`Topic-a`。此时有一条消息发往`Topic-a`，那么这两个消费组都能接收到这条消息。





## 常见问题

### 如何保证消息不丢失

我们一般采用消息队列都是第三方的消息队列，RabbitMQ,RocketMQ等等，只要配置得当就不会出现消息丢失的情况。

![image-20211010150349749](https://picturebedzhanghui.oss-cn-hangzhou.aliyuncs.com/img/image-20211010150349749.png)

从理论上来看，分为三个阶段：**生产者生产消息、消息队列存储消息、消费者消费消息**，从这三个阶段来保证消息不丢失。

#### 生产消息

生产者生产消息传输给消息队列后，**需要处理Broker的响应**，对应响应的处理很重要，无论是异步还是同步传输，响应回调时都要做好

**try-catch**，妥善处理响应。若Broker响应失败，就需要让生产者重新发送。当多次发送还是失败时就要做报警处理、日志记录的操作。



#### 存储消息

存储消息时需要在**消息刷盘时**再给生产者响应，例如传输过来的消息刚写入缓存就响应生产者，生产者认为自己已经发送成功，突然机器宕机了，缓存中的消息就没有了，生产者不会再发送消息了，这样就会产生消息丢失。

当Broker是处于单机的情况下，等消息刷盘后（**存储在本地**）返回响应。若Broker是在集群的情况下，存在多个消息队列，各个队列之间要进行信息同步，至少要保证两台机器写入了消息之后再回返给生产者，防止宕机后数据丢失。



#### 消费消息

消费者从Broker中拿到消息后写入内存就进行返回，机器宕机的这样情况，很可能造成数据的丢失，因此需要等待消费者消费完毕后才进行返回，这样就能保证数据完整性。



整个过程需要三个阶段相互配合，保证消息不会丢失。

但是要注意**消息可靠性增强了，性能就下降了**，等待消息刷盘、多副本同步后返回都会影响性能。因此还是看业务，例如日志的传输可能丢那么一两条关系不大，因此没必要等消息刷盘再响应。



### 如何保证消息的有序性

有序性：**全局有序和部分有序**

#### 全局有序

保证全局的有序，保证只有一个生产者往Topic发送消息，并且该Topic中只有一个队列，对应的消费这也是单线程。

<img src="https://picturebedzhanghui.oss-cn-hangzhou.aliyuncs.com/img/image-20211010153324058.png" alt="image-20211010153324058" style="zoom:80%;" />

#### 部分有序

绝大部分的有序需求就是：部分有序。

将Topic中划分成我们需要的队列数，通过不同策略将对应的消息传到对应的队列中，每个队列对应一个单线程的消费者。

能够保证保证部分有序的需求，又提高了并发量。

<img src="https://picturebedzhanghui.oss-cn-hangzhou.aliyuncs.com/img/image-20211010153738502.png" alt="image-20211010153738502" style="zoom:80%;" />

### 如何处理消息堆积

消息堆积的原因在于：**生产者生产速率于消费者消费速率不平衡导致**。

首先我们要定位 **消费慢的原因**。如果是bug则处理bug。如果是消费者本身的原因，我们可以通过优化逻辑来增加消费者消费速率。

例如之前是一条一条消息消费处理的，这次我们批量处理，比如数据库的插入，一条一条插和批量插效率是不一样的。



在优化逻辑之后，消息还是堆积不减，就需要考虑增加Topic中队列数量和消费者数目。在Topic中一个队列对应一个消费者。



### 如何处理重复消息

**考虑能不能避免消息的重复**！

假如生产者只管生产消息，发送给Broker，也不管Broker响应，那么生产者不会发送第二遍同样的数据。但是现实是不可以这样的，这

样的消息是完全不可靠的，消息丢失。

我们的基本需求是消息至少得发到`Broker`上，那就得等`Broker`的响应，那么就可能存在`Broker`已经写入了，当时响应由于网络原因生

产者没有收到，然后生产者又重发了一次，**此时消息就重复了**。

再看消费者消费的时候，假设我们消费者拿到消息消费了，业务逻辑已经走完了，事务提交了，此时需要更新`Consumer offset`了，然

后这个消费者挂了，另一个消费者顶上，此时`Consumer offset`还没更新，于是又拿到刚才那条消息，业务又被执行了一遍。于是消息

又重复了。

**重复消息无法避免，那么只能动手解决问题了**

关键点就是**幂等**。既然我们不能防止重复消息的产生，那么我们只能在业务上处理重复消息所带来的影响。

**幂等处理重复消息**

例如这条 SQL `update t1 set money = 150 where id = 1 and money = 100;` 执行多少遍`money`都是150，这就叫幂等。

因此需要改造业务处理逻辑，使得在重复消息的情况下也不会影响最终的结果。

可以通过上面我那条 SQL 一样，做了个**前置条件判断**，即`money = 100`情况，并且直接修改，更通用的是做个`version`即版本号控制，

对比消息中的版本号和数据库中的版本号。

或者通过**数据库的约束例如唯一键**，例如`insert into update on duplicate key...`。

或者**记录关键的key**，比如处理订单这种，记录订单ID，假如有重复的消息过来，先判断下这个ID是否已经被处理过了，如果没处理再进

行下一步。当然也可以用全局唯一ID等等。

基本上就这么几个套路，**真正应用到实际中还是得看具体业务细节**。

